---
date: "2018-03-24 17:57:58"
title: Reactive微服务
---
# Reactive微服务

分布式系统构建起来很困难，因为它们容易出问题，运行缓慢，并且被CAP和FLP理论所限制。换句话说，它们的构建和运维都特别复杂。为了解决这个问题，reactive便出现了。

Reactive编程：一种开发模型，其专注于数据流向、对变化的反馈，以及传播他们。

在reactive编程中，刺激信号是数据的转移，叫做streams。其实很像生产者——消费者模式，消费者对值进行订阅并响应。

Reactive系统：一种架构风格，其基于异步消息来构建响应式的分布式系统。

reactive系统使用了消息驱动的方法。所有的构建通过异步消息的发送和接收来交互。消息投递的逻辑由底层的实现决定。发送者不会阻塞着等待回复，它们可能会稍后才接收到回复。

reactive系统会有两个重要的特征：

- 伸缩性——可以横向伸缩

  伸缩性来自消息传递的解耦。消息被发送到一个地址之后，可以被一组消费者按照一种负载均衡方法消费。当reactive系统遇到负载高峰时，它可以创造出新的消费者，并在此之后销毁它们。

- 恢复性——可以处理错误并且恢复

  首先，这种消息交互模式允许组件在其本地处理错误，组件不需要等待消息，因此当一个组件发生错误时，其他组件仍然会正常工作。其次，当一个处理消息的组件发生错误后，消息可以可以传递给在相同地址注册的其他组件。

reactive微服务系统是由reactive微服务组成的。这些微服务有下面四个特征：

- 自治性
- 异步性
- 恢复性
- 伸缩性

Reactive微服务是可自治的。他们可以根据周围的服务是否可用来调整自己的行为。自治性往往伴随着孤立性；Reactive微服务可以在本地处理错误、独立地完成任务，并在必要时和其他服务合作。它们使用异步消息传递的机制和其他服务沟通；它们也会接收消息并且对其作出回应。

得益于异步消息机制，reactive微服务可以处理错误并根据情况调整自己的行为。错误不会被扩散，而是在靠近错误源头的地方被处理掉。当一个微服务挂掉之后，它的消费者微服务要能够处理错误并避免扩散。这一孤立原则是避免错误逐层上浮而毁掉整个系统的关键。可恢复性不只是关于处理错误，它还涉及到自愈性；一个reactive微服务应该能够从错误中恢复并且对错误进行补救。

最后，reactive微服务必须是可伸缩的，这样系统才可以根据负载情况来调整节点数量。这一特性意味着将会有一系列的限制，比如不能有在内存中的状态，要能够在必要时同步状态信息，或者要能够将消息路由到状态信息相同的节点。

## Vert.x

Vert.x是一个用于构建reactive和分布式系统的工具箱，其使用了异步非阻塞编程模型。当使用Vert.x构建微服务的时候，微服务会自然地带上一个核心特征：所有事情都是异步的。

传统编程模式

```
int res = compute(1, 2);
```

在这段代码中，是在等待compute函数计算出来结果之后再进行剩下的操作。而在异步非阻塞的编程模式中，将会创建一个handler：

```
compute(1, 2, res -> {
    // called with the result
});
```

在上述代码中，compute函数不再返回一个结果，而是传一个handler，当结果准备好时调用就可以了。得益于这种开发模型，可以使用很少的线程去处理高并发工作。在vert.x中，到处都可以看到这种形式的代码，比如创建http服务器时：

```
vertx.createHttpServer()
    .requestHandler(request -> {
        request.response().end("hello vert.x");
    })
    .listen(8080);
```

这个例子中，我们让一个requestHandler接收HTTP请求(事件)并且返回"hello vert.x"。Handler是一个函数，当事件发生时，它会被调用。在我们的例子中，handler代码会在每次请求进来时被调用执行。要注意的是，Handler并不会返回一个结果，但是它可以提供一个结果；这个结果是怎样被提供的，这个要看是哪种交互行为。在上面的代码段中，它只是向一个HTTP response写入了结果。这个Handler后面跟了一个方法令其监听8080端口。调用这个HTTP服务它会返回一个简单的response。

### event loop

绝大多数情况，Vert.x会用一个叫做event loop的线程来调用所有的handler。

![](https://upload-images.jianshu.io/upload_images/3153856-e1219f95986959b0.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)

基于消息循环的线程模型有一个很大的优点：它简化了并发。因为只有一个线程存在，因此永远都只被一个线程调用而不存在并发的情况。但是同样也有一个限制：

> 不要阻塞消息循环

因为没有阻塞，一个消息循环线程可以短时间内分发巨量的事件，这个模式就叫做reactor模式。

### verticles

Verticles是被Vert.x部署和运行的代码块。一个微服务的应用，是由运行在同一个Vert.x实例上的若干verticle组成的。一个verticle通常会创建服务器或客户端、注册一组Handler，以及封装一部分系统的业务处理逻辑。

#### 标准的verticle

标准的verticle会在Vert.x的消息循环中被执行，并且永远不会阻塞。Vert.x保证了每一个verticle都会只被同一个线程执行而不会有并发发生，从而避免同步工作。

#### Worker Verticle

和标准的verticle不同，worker verticle不是在消息循环中执行的，这就意味着他们可以执行阻塞代码。但是，这会限制你的可扩展性。

Verticle可以访问vertx成员变量(是由AbstractVerticle类提供的)来创建服务器和客户端，以及和其他的verticle交互。Verticle还可以部署其他的verticle，对它们进行配置，并设置创建实例的数量。这些实例会和不同的消息循环线程绑定，Vert.x通过这些实例来均衡负载。

### 从Callbacks到Observables

我们可以发现，Vert.x开发模式使用回调方法。在组织管理多个异步动作时，这种基于回调的开发模式容易产生复杂的代码，陷入callback hell。

Vert.x提供了解决这个开发难题的答案——RxJava API。