---
date: "2018-08-23 15:14:02"
title: 区块链学习笔记
---

> 本文是阅读http://www.netkiller.cn/blockchain/ch01s10.html上的一些笔记。

## 理解区块链的分布式记账

http://www.netkiller.cn/blockchain/ch01s10.html

区块链中提到的账本，记账等词汇是和会计无关的词汇。

我们传统理解的账本是一个二维的表格，记录了某年某月某日的费用：

| 时间       | 用途 | 金额 |
| ---------- | ---- | ---- |
| 2018-08-23 | 借   | 100  |
| 2018-08-22 | 还   | 200  |
| 2018-08-21 | 借   | 50   |
| 2018-08-20 | 还   | 1000 |

如果账目比较多，可以拆账，将不同分类的账目放在特定的账本中，而且二维表格还可以设置索引等，快速找到一笔交易。

但是区块链的记账形式是：

![](https://ws4.sinaimg.cn/large/006tNbRwgy1fujnyii772j30ku08twex.jpg)

可以发现，区块链的这种记账方式是做了行列矩阵转换，节点之间收尾相互连接，成为链式结构，所有的账目都在一条链上。

**所谓分布式记账，其实就是上述链状的数据结构保存在所有的节点上，形成分布式集群。**

之所以采用区块链来做分布式记账，主要是区块链有如下好处：

- 去中心化

  传统的数据库存储是中心化的，通过暴露ip地址和端口号提供服务，后来分布式进群化之后，出现了主主从架构等。

  与数据库相比，区块链是多主架构，而且实现更为复杂，节点之间的数据之间不是简单的二进制日志同步，而是要通过加密技术，节点达成共识之后才存储。

- 可追溯

- 安全

  安全分为很多层，区块链只能做到存储层的安全。

  区块链无法解决用户层，应用层，逻辑层等安全问题，他只能保证存储在硬盘上的区块不被修改。

- 不可篡改

  很多人认为区块链数据一旦创建之后就不能修改，所以采用区块链技术很安全。其实不然，数据是可以修改的，但是不能篡改。

  撰改是指非法修改区块链数据，而修改则是合法变更数据。

  通常撰改区块链数据多指数据存储层面的修改。而修改则是通过合约提供的修改函数变更区块链里面的数据。

  多数区块链平台没有用户认证权限管理模块。所以无法控制区块中的哪些数据能被修改，哪些不能修改，哪些用户可以修改等等。即使有些区块链平台具备权限控制，颗粒度也无法达到目前的数据库控制的那么细。

采用区块链作为账本的时候，会面临如下几个问题：

- 不能建立索引，无法快速搜索出区块中的数据，必须依赖区块链以外的技术，如搜索引擎，数据库等。例如；etherscan.io就是把以太坊上的区块重新入库，借助数据库实现数据检索。

- 区块链只能顺序检索，运算成本高。例如在中心化账本中汇总求和操作，区块链必须从头向后遍历。

- 所有账目均在一条链上，不同的分类混在一起，彼此相连。

- 无法归档。

  传统的数据库，我们可以归档一段时间内的数据，而这些归档的数据基本都是冷数据，不会再被查询，归档数据的备份到存储介质上的解决方案也有很多。

  但是区块链的数据都是热数据，任何新增的节点都必须从0开始同步，并且保证同步到最新区块，否则可能无法完成交易，数据会一直膨胀下去。

  虽然有算法能够减少同步的量，但是现阶段的体验仍然不好。

- 没有事务处理。

  因为区块链是首尾相连的链式结构，所以只能在尾部加区块，无法修改中间的区块。假设有个区块回滚，该区块的hash产生变化，后面的区块都要作废。

  所以当并发执行的时候，可能会出现混乱。因此我们要在应用层做一些处理。

-  性能问题

  - 由于是异步执行，无法预测何时完成。
  - 交易容易阻塞

- gas费用。

## 区块链落地的一些问题和解决方案

如果要在企业中落地区块链，尝尝有如下解决方案：

- 解决性能问题

  目前区块链只适合做**低频高价值业务**。

  读取性能通常是没有问题的，但是写入实际上无论你用多少个服务器节点都不能提升，因为写入区块需要做共识算法，这步操作，会在所有节点上进行，同时还需要加密运算，这些操作都是 CPU 密集型操作。

  方案：

  - 通过消息队列技术异步写入，将需要写入的区块放入队列，异步完成上链操作。

  - 并行写入，我们可以建设多个区块链平台。多个平台同时服务于业务。

    为了达到去中心化并行写入，我们将在客户端通过算法，匹配服务器。因为如果在平台前面增加负载均衡，加因为这样又回到了中心化系统。

- 溯源颗粒度

  对于所要被溯源的物品或者交易来讲，有四种情况，低频低价值，低频高价值，高频高价值，高频低价值 。

  对于低频高价值和高频高价值的业务，尽量做到最小颗粒度。

  对于低频低价值和高频低价值的业务，可以颗粒度更粗。

- 和传统数据库互补

  区块链技术本身是一种追求分布一致性的数据库。

  我们都知道CAP理论。CAP理论是指的是在一个分布式系统中， Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。大多数区块链，放弃了一些可用性，偏向了一致性和分区容错。

  区块链并非能解决所有问题，虽然他也算是一种数据库，它能解决问题十分有限，它的数据管理和查询能力还打不到 NoSQL 的水平，更别提 SQL 的复杂应用。所以在实际的应用中，区块链不能替代传统数据库，只能互补。

- 链上链下数据一致性问题

  既然区块链替代不了传统数据库，那么必然要在项目中同时使用两种技术。这样问题来了，会有两份数据，一份存储在链下，即传统数据库，另外一部分数据上链，这样就有两份重复的数据，那么怎样保证他们的一致性呢？

  区块链和比特币网络不同，比特币是在链上产生的，它与区块链密布可分，是一体的，所以它的数据安全性是自闭环的。而我们的链下数据并不是在区块链中产生的，因此我们在上链的时候，尽量采用如下的方案：

  - 两端都做一次哈希，可快速对比数据是否一致
  - 以链上数据为准，因为数据库的数据更容易被篡改
  - 前端业务走链，后端业务走数据库，因为前台业务是为用户提供服务，所以要走链上数据，而后台是可以管理的，走数据库即可。
  - 共享数据上链，私有数据不上链。

## 区块链的相关技术

区块链的技术模型自下而上分为；数据层，网路层，共识层，激励层，合约层以及应用层。

- 数据层，封装了底层数据区块的链式结构，以及相关的非对称公私钥数据加密技术和时间戳等技术，这是整个区块链技术中最底层的数据结构。

  这些技术是构建全球金融系统的基础，数十年的使用证明了它非常安全的可靠性。而区块链，正式巧妙地把这些技术结合在了一起。

- 网络层，包括P2P组网机制、数据传播机制和数据验证机制等。

  P2P组网技术早期应用在BT这类P2P下载软件中，这就意味着区块链具有自动组网功能。

- 共识层，封装了网络节点的各类共识机制算法。共识机制算法是区块链的核心技术，因为这决定了到底是谁来进行记账，而记账决定方式将会影响整个系统的安全性和可靠性。

  数据层、网络层、共识层是构建区块链技术的必要元素，缺少任何一层都将不能称之为真正意义上的区块链技术。

  目前已经出现了十余种共识机制算法，其中比较最为知名的有工作量证明机制（PoW，Proof of Work）、权益证明机制（PoS，Proof ofStake）、股份授权证明机制（DPoS，Delegated ProofofStake）等。

- 激励层，将经济因素集成到区块链技术体系中来，包括经济激励的发行机制和分配机制等，主要出现在公有链当中。

  在公有链中必须激励遵守规则参与记账的节点，并且惩罚不遵守规则的节点，才能让整个系统朝着良性循环的方向发展。而在私有链当中，则不一定需要进行激励，因为参与记账的节点往往是在链外完成了博弈，通过强制力或自愿来要求参与记账。

- 合约层，封装各类脚本、算法和智能合约，是区块链可编程特性的基础。

  比特币本身就具有简单脚本的编写功能，而以太坊极大的强化了编程语言协议，理论上可以编写实现任何功能的应用。如果把比特币看成是全球账本的话，以太坊可以看作是一台“全球计算机”，任何人都可以上传和执行任意的应用程序，并且程序的有效执行能得到保证。

- 应用层，封装了区块链的各种应用场景和案例，比如搭建在以太坊上的各类区块链应用即部署在应用层，而未来的可编程金融和可编程社会也将会是搭建在应用层。

共识算法

- pow
- pos
- dpos
- poa
- pbft
- raft

HD Wallet

BIP32 定义 Hierarchical Deterministic wallet (简称 "HD Wallet")，是一个系统可以从单个seed产生树状结构储存多组 keypairs（私钥和公钥）。

BIP39 定义钱包助记词和seed生成规则，一般由 12 -24个单字组成，称为 mnemonic。

BIP44 基于 BIP32 的系统，赋予树状结构中的各层特殊的意义。让同一个 seed 可以支援多币种、多帐户等 。

使用助记词生成确定性钱包。

HD Wallet 采用 2048 个单词，或者汉字作为助记词，这些词库对外公开，很多钱包仅仅使用path第一个地址并且没有加密。如果你知道某个用户的助记词中的11各词的排列顺序，那么我们就可以通过穷举方法，算出所有地址的私钥，如果碰巧找到了已经在使用的地址。就可以将里面的ETH全部转走。

## 以太坊常用操作

计算gas费用

```
var estimateGas = eth.estimateGas({from:eth.accounts[1], to: eth.accounts[2], value: web3.toWei(1)})

var cost = estimateGas * gasPrice
```

解锁账户

```
personal.unlockAccount(eth.accounts[3], "12345678")
```

转账

```
var txnHash = eth.sendTransaction({from: eth.accounts[3], to: eth.accounts[5], value: eth.getBalance(eth.accounts[3]) - cost, gas: estimateGas})
```

查看交易细节

```
web3.eth.getTransaction(txnHash)
```

获取余额

```
eth.getBalance(eth.accounts[3])
```

keystore文件

以太坊的每个外部账户都是由一对密钥（一个公钥和一个私钥）定义的。账户以地址为索引，地址由公钥衍生而来，取公钥的最后 20个字节。

每对私钥 /地址都编码在一个钥匙文件里，也就是我们说的keystore文件。该文件是 JSON 文本文件，可以用任何文本编辑器打开和浏览。钥匙文件的关键部分——账户私钥，通常用你创建帐户时设置的密码进行加密。如果你丢失了这个文件，你就丢失了私钥，意味着你失去了签署交易的能力，意味着你的资金被永久的锁定在了你的账户里。

批量转账

有时我们需要将Token发送到多个地址上去。通常的做法就是使用web.js写一个循环程序，但是实际使用过程中发现这种做法存在很多问题，常会发生转账失败情况。

经过分析造成发送失败原因是，频率太高，因为web.js 是异步操作，当前程序还未完成交易，交易尚未确认的情况下第二笔交易发送出去，这时就会出错。

```
web3.eth.getTransactionCount(from).then(function(nonce){
	// 问题就出在 nonce ， nonce 如同数据库中的序列主键，如果上一个交易没有完成，下一个交易取得 nonce + 1 后与上一个 pending 的交易相同，产生冲突
}	
```

最好的解方案是在合约中实现批量转账功能，这样需要一个交易 txhash 完成多比交易。

如果你的Token已经在使用了，且没有批量转账的功能怎么解决呢？我们可以在写一个Token 继承原来的Token，在新的 Token 中实现批量转账功能。

代币兑换

兑换代币通常是指使用 ETH 或者其他币兑换Token。通常是这样实现的，使用智能合约，将 ETH 达到指定合约地址，合约会打回代币给用户。

这种方式不用人工参与，也不用开发程序。缺点不能做到实时汇率，需要人工设置汇率。

ERC20 Token

ERC20 “描述了实现代币合约的标准功能”，ERC20 是各个代币的标准接口。ERC20 代币仅仅是以太坊代币的子集。为了充分兼容 ERC20，开发者需要将一组特定的函数集成到他们的智能合约中，以便在高层面能够执行以下操作：

- 获得代币总供应量
- 获得账户余额
- 转让代币
- 批准花费代币

最简单的合约如下：

```
pragma solidity ^0.4.24;

contract EncryptToken {
    uint256 INITIAL_SUPPLY = 666666;
    mapping(address => uint256) balances;

    constructor() public {
        balances[msg.sender] = INITIAL_SUPPLY;
    }

    function transfer(address to, uint256 amount) public{
        assert(balances[msg.sender] > amount);
        balances[msg.sender] -= amount;
        balances[to] += amount;
    }

    function balanceOf(address owner) constant  public returns (uint256){
        return balances[owner];
    }

}
```

使用了openzeppeline-solidity的安全标准代币合约是：

```
  pragma solidity ^0.4.24;
  import "openzeppelin-solidity/contracts/token/ERC20/StandardToken.sol";

  contract BloggerCoin is StandardToken{
      string public name = "BloggerCoin";  // 名字
      string public symbol = "BLC";   // 简称
      uint8 public decimals = 4;   // 10的4次方
      uint256 public INITIAL_SUPPLY = 666666;

      constructor() public{
          totalSupply_ = INITIAL_SUPPLY;
          balances[msg.sender] = INITIAL_SUPPLY;
      }
  }
```

