<html>
    <head>
        <title> 
            Reactive微服务
        </title>

    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.1.0/build/styles/default.min.css"
    />
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.1.0/build/highlight.min.js"></script>

    <script>
      hljs.highlightAll();
    </script>

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      .markdown-body {
        box-sizing: border-box;
        min-width: 200px;
        max-width: 980px;
        margin: 0 auto;
        padding: 45px;
      }

      @media (max-width: 767px) {
        .markdown-body {
          padding: 15px;
        }
      }
    </style>
    </head>

    <body>
        <div>
            <article class="markdown-body"> 
                <hr class="thin" />
<p>
date: “2018-03-24 17:57:58”
title: Reactive微服务</p>
<hr class="thin" />
<h1>
Reactive微服务</h1>
<p>
分布式系统构建起来很困难，因为它们容易出问题，运行缓慢，并且被CAP和FLP理论所限制。换句话说，它们的构建和运维都特别复杂。为了解决这个问题，reactive便出现了。</p>
<p>
Reactive编程：一种开发模型，其专注于数据流向、对变化的反馈，以及传播他们。</p>
<p>
在reactive编程中，刺激信号是数据的转移，叫做streams。其实很像生产者——消费者模式，消费者对值进行订阅并响应。</p>
<p>
Reactive系统：一种架构风格，其基于异步消息来构建响应式的分布式系统。</p>
<p>
reactive系统使用了消息驱动的方法。所有的构建通过异步消息的发送和接收来交互。消息投递的逻辑由底层的实现决定。发送者不会阻塞着等待回复，它们可能会稍后才接收到回复。</p>
<p>
reactive系统会有两个重要的特征：</p>
<ul>
  <li>
    <p>
伸缩性——可以横向伸缩    </p>
    <p>
伸缩性来自消息传递的解耦。消息被发送到一个地址之后，可以被一组消费者按照一种负载均衡方法消费。当reactive系统遇到负载高峰时，它可以创造出新的消费者，并在此之后销毁它们。    </p>
  </li>
  <li>
    <p>
恢复性——可以处理错误并且恢复    </p>
    <p>
首先，这种消息交互模式允许组件在其本地处理错误，组件不需要等待消息，因此当一个组件发生错误时，其他组件仍然会正常工作。其次，当一个处理消息的组件发生错误后，消息可以可以传递给在相同地址注册的其他组件。    </p>
  </li>
</ul>
<p>
reactive微服务系统是由reactive微服务组成的。这些微服务有下面四个特征：</p>
<ul>
  <li>
自治性  </li>
  <li>
异步性  </li>
  <li>
恢复性  </li>
  <li>
伸缩性  </li>
</ul>
<p>
Reactive微服务是可自治的。他们可以根据周围的服务是否可用来调整自己的行为。自治性往往伴随着孤立性；Reactive微服务可以在本地处理错误、独立地完成任务，并在必要时和其他服务合作。它们使用异步消息传递的机制和其他服务沟通；它们也会接收消息并且对其作出回应。</p>
<p>
得益于异步消息机制，reactive微服务可以处理错误并根据情况调整自己的行为。错误不会被扩散，而是在靠近错误源头的地方被处理掉。当一个微服务挂掉之后，它的消费者微服务要能够处理错误并避免扩散。这一孤立原则是避免错误逐层上浮而毁掉整个系统的关键。可恢复性不只是关于处理错误，它还涉及到自愈性；一个reactive微服务应该能够从错误中恢复并且对错误进行补救。</p>
<p>
最后，reactive微服务必须是可伸缩的，这样系统才可以根据负载情况来调整节点数量。这一特性意味着将会有一系列的限制，比如不能有在内存中的状态，要能够在必要时同步状态信息，或者要能够将消息路由到状态信息相同的节点。</p>
<h2>
Vert.x</h2>
<p>
Vert.x是一个用于构建reactive和分布式系统的工具箱，其使用了异步非阻塞编程模型。当使用Vert.x构建微服务的时候，微服务会自然地带上一个核心特征：所有事情都是异步的。</p>
<p>
传统编程模式</p>
<pre><code>int res = compute(1, 2);</code></pre>
<p>
在这段代码中，是在等待compute函数计算出来结果之后再进行剩下的操作。而在异步非阻塞的编程模式中，将会创建一个handler：</p>
<pre><code>compute(1, 2, res -&gt; {
    // called with the result
});</code></pre>
<p>
在上述代码中，compute函数不再返回一个结果，而是传一个handler，当结果准备好时调用就可以了。得益于这种开发模型，可以使用很少的线程去处理高并发工作。在vert.x中，到处都可以看到这种形式的代码，比如创建http服务器时：</p>
<pre><code>vertx.createHttpServer()
    .requestHandler(request -&gt; {
        request.response().end(&quot;hello vert.x&quot;);
    })
    .listen(8080);</code></pre>
<p>
这个例子中，我们让一个requestHandler接收HTTP请求(事件)并且返回”hello vert.x”。Handler是一个函数，当事件发生时，它会被调用。在我们的例子中，handler代码会在每次请求进来时被调用执行。要注意的是，Handler并不会返回一个结果，但是它可以提供一个结果；这个结果是怎样被提供的，这个要看是哪种交互行为。在上面的代码段中，它只是向一个HTTP response写入了结果。这个Handler后面跟了一个方法令其监听8080端口。调用这个HTTP服务它会返回一个简单的response。</p>
<h3>
event loop</h3>
<p>
绝大多数情况，Vert.x会用一个叫做event loop的线程来调用所有的handler。</p>
<p>
  <img src="https://upload-images.jianshu.io/upload_images/3153856-e1219f95986959b0.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="" />
</p>
<p>
基于消息循环的线程模型有一个很大的优点：它简化了并发。因为只有一个线程存在，因此永远都只被一个线程调用而不存在并发的情况。但是同样也有一个限制：</p>
<blockquote>
  <p>
不要阻塞消息循环  </p>
</blockquote>
<p>
因为没有阻塞，一个消息循环线程可以短时间内分发巨量的事件，这个模式就叫做reactor模式。</p>
<h3>
verticles</h3>
<p>
Verticles是被Vert.x部署和运行的代码块。一个微服务的应用，是由运行在同一个Vert.x实例上的若干verticle组成的。一个verticle通常会创建服务器或客户端、注册一组Handler，以及封装一部分系统的业务处理逻辑。</p>
<h4>
标准的verticle</h4>
<p>
标准的verticle会在Vert.x的消息循环中被执行，并且永远不会阻塞。Vert.x保证了每一个verticle都会只被同一个线程执行而不会有并发发生，从而避免同步工作。</p>
<h4>
Worker Verticle</h4>
<p>
和标准的verticle不同，worker verticle不是在消息循环中执行的，这就意味着他们可以执行阻塞代码。但是，这会限制你的可扩展性。</p>
<p>
Verticle可以访问vertx成员变量(是由AbstractVerticle类提供的)来创建服务器和客户端，以及和其他的verticle交互。Verticle还可以部署其他的verticle，对它们进行配置，并设置创建实例的数量。这些实例会和不同的消息循环线程绑定，Vert.x通过这些实例来均衡负载。</p>
<h3>
从Callbacks到Observables</h3>
<p>
我们可以发现，Vert.x开发模式使用回调方法。在组织管理多个异步动作时，这种基于回调的开发模式容易产生复杂的代码，陷入callback hell。</p>
<p>
Vert.x提供了解决这个开发难题的答案——RxJava API。</p>

            </article>
        </div>
    </body>
</html>

    