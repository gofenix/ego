<html>
    <head>
        <title> 
            以太坊
        </title>

    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.1.0/build/styles/default.min.css"
    />
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.1.0/build/highlight.min.js"></script>

    <script>
      hljs.highlightAll();
    </script>

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      .markdown-body {
        box-sizing: border-box;
        min-width: 200px;
        max-width: 980px;
        margin: 0 auto;
        padding: 45px;
      }

      @media (max-width: 767px) {
        .markdown-body {
          padding: 15px;
        }
      }
    </style>
    </head>

    <body>
        <div>
            <article class="markdown-body"> 
                <hr class="thin" />
<p>
date: “2018-08-07 20:09:26”
title: 以太坊</p>
<hr class="thin" />
<p>
参与了公司的一个项目，上了以太坊，这里简单记录一下踩坑。</p>
<p>
首先先把go的依赖下载下来：</p>
<pre><code>go get -u -v github.com/ethereum/go-ethereum</code></pre>
<p>
有时候下载的很慢，可以从github上拉下来代码。</p>
<h2>
账户</h2>
<p>
以太坊的地址在离线状态下也可以创建到。</p>
<p>
创建账户有两种方式：</p>
<h4>
以公钥和私钥的形式创建</h4>
<pre><code>func CreateAccount() (string, error) {
    key, err := crypto.GenerateKey()
    if err != nil {
        log.Fatalln(err)
        return &quot;&quot;, nil
    }

    address := crypto.PubkeyToAddress(key.PublicKey).Hex()
    log.Println(&quot;address: &quot;, address)

    privateKey := hex.EncodeToString(key.D.Bytes())
    log.Println(&quot;privateKey: &quot;, privateKey)
    return address, nil
}</code></pre>
<p>
这种方式一般用的比较少。</p>
<h4>
以keystore的形式创建</h4>
<p>
keystore会创建一个文件，这个文件如下所示：</p>
<pre><code class="on">{
  &quot;address&quot;: &quot;d93688757810e644f0b9c162102d9c598813f0dd&quot;,
  &quot;crypto&quot;: {
    &quot;cipher&quot;: &quot;aes-128-ctr&quot;,
    &quot;ciphertext&quot;:
      &quot;71ae7c8144729b2f9e0c51d95c6dfb73e63f14b5332b3594e8a1f325237c27ed&quot;,
    &quot;cipherparams&quot;: { &quot;iv&quot;: &quot;620c73001081c014a862ce80003a4648&quot; },
    &quot;kdf&quot;: &quot;scrypt&quot;,
    &quot;kdfparams&quot;: {
      &quot;dklen&quot;: 32,
      &quot;n&quot;: 262144,
      &quot;p&quot;: 1,
      &quot;r&quot;: 8,
      &quot;salt&quot;: &quot;bd272aa37271ef9913eb095a4d143be238e348c48fce6459896e1bb1b0236741&quot;
    },
    &quot;mac&quot;: &quot;2b3ade771645090a2b34c214906c592a1300d529e459faefb1421ba496b6fe1d&quot;
  },
  &quot;id&quot;: &quot;e4dd5384-56a8-4ec7-b6e0-492dcd3742e9&quot;,
  &quot;version&quot;: 3
}</code></pre>
<p>
在生成这个文件的时候，会让你输一个密码，这个文件加密码其实就是一个私钥。</p>
<pre><code>// 理论上来讲，这个函数应该只被创建一次即可
// 创建一个账户
func CreateWallet() (key, addr string) {
    ks := keystore.NewKeyStore(&quot;/Users/zhuzhenfeng/Documents/github/gowork/src/geth-demo/&quot;, keystore.StandardScryptN, keystore.StandardScryptP)
    account, _ := ks.NewAccount(&quot;password&quot;)
    key_json, err := ks.Export(account, &quot;password&quot;, &quot;password&quot;)
    if err != nil {
        log.Fatalln(&quot;导出账户错误: &quot;, err)
        panic(err)
    }
    key = string(key_json)
    addr = account.Address.Hex()
    return
}</code></pre>
<p>
这个key和address，”password”是这个文件的密码。</p>
<h2>
私链</h2>
<p>
一种方式是连接互联网上的测试链，一种是连接本地的私链。</p>
<h4>
本地私链的启动</h4>
<p>
启动本地私链最简单的一种方式是用Truffle提供的Ganache，只要将它下载下来，启动起来即可。</p>
<p>
  <img src="https://ws1.sinaimg.cn/large/0069RVTdgy1fu1f8kub6vj30xc0m8aet.jpg" alt="image-20180807202239542" />
</p>
<p>
可以看到已经启动了，连接的地址是:</p>
<pre><code>http://127.0.0.1:7545</code></pre>
<h4>
互联网上的测试链地址</h4>
<pre><code>https://rinkeby.infura.io/v3/6c81fb1b66804f0698d49f2ec242afc9</code></pre>
<h4>
连接</h4>
<p>
我们用geth的rpc连接上面的私链地址即可：</p>
<pre><code>func connectRPC() (*ethclient.Client, error) {
    // 连接测试链的节点
    //rpcClient, err := rpc.Dial(&quot;https://rinkeby.infura.io/v3/6c81fb1b66804f0698d49f2ec242afc9&quot;)
    rpcClient, err := rpc.Dial(&quot;http://127.0.0.1:7545&quot;)
    if err != nil {
        log.Fatalln(err)
        return nil, err
    }

    conn := ethclient.NewClient(rpcClient)
    return conn, nil
}</code></pre>
<h2>
其他操作</h2>
<p>
在上一步中连接rpc中，拿到了client。用这个client就可以做很多事儿：</p>
<h3>
获取余额</h3>
<pre><code>func GetBalance(address string) (float64, error) {
    client, err := connectRPC()
    if err != nil {
        log.Fatalln(&quot;err: &quot;, err)
        panic(err)
    }

    balance, err := client.BalanceAt(context.TODO(), common.HexToAddress(address), nil)
    if err != nil {
        log.Fatalln(balance)
        return 0, err
    }
    balanceV := float64(balance.Int64()) * math.Pow(10, -18)
    return balanceV, nil
}</code></pre>
<h3>
代币转账</h3>
<p>
要生成代币，需要写一个token的合约。可以用这一个最简单的token.abi。复杂一般可以用truffle框架来编写。</p>
<pre><code class="on">// token.abi
[
  {
    &quot;anonymous&quot;: false,
    &quot;inputs&quot;: [
      {
        &quot;indexed&quot;: true,
        &quot;name&quot;: &quot;from&quot;,
        &quot;type&quot;: &quot;address&quot;
      },
      {
        &quot;indexed&quot;: true,
        &quot;name&quot;: &quot;to&quot;,
        &quot;type&quot;: &quot;address&quot;
      },
      {
        &quot;indexed&quot;: false,
        &quot;name&quot;: &quot;value&quot;,
        &quot;type&quot;: &quot;uint256&quot;
      }
    ],
    &quot;name&quot;: &quot;Transfer&quot;,
    &quot;type&quot;: &quot;event&quot;
  },
  {
    &quot;constant&quot;: true,
    &quot;inputs&quot;: [],
    &quot;name&quot;: &quot;totalSupply&quot;,
    &quot;outputs&quot;: [
      {
        &quot;name&quot;: &quot;&quot;,
        &quot;type&quot;: &quot;uint256&quot;
      }
    ],
    &quot;payable&quot;: false,
    &quot;stateMutability&quot;: &quot;view&quot;,
    &quot;type&quot;: &quot;function&quot;
  },
  {
    &quot;constant&quot;: false,
    &quot;inputs&quot;: [
      {
        &quot;name&quot;: &quot;_to&quot;,
        &quot;type&quot;: &quot;address&quot;
      },
      {
        &quot;name&quot;: &quot;_value&quot;,
        &quot;type&quot;: &quot;uint256&quot;
      }
    ],
    &quot;name&quot;: &quot;transfer&quot;,
    &quot;outputs&quot;: [
      {
        &quot;name&quot;: &quot;&quot;,
        &quot;type&quot;: &quot;bool&quot;
      }
    ],
    &quot;payable&quot;: false,
    &quot;stateMutability&quot;: &quot;nonpayable&quot;,
    &quot;type&quot;: &quot;function&quot;
  },
  {
    &quot;constant&quot;: true,
    &quot;inputs&quot;: [
      {
        &quot;name&quot;: &quot;_owner&quot;,
        &quot;type&quot;: &quot;address&quot;
      }
    ],
    &quot;name&quot;: &quot;balanceOf&quot;,
    &quot;outputs&quot;: [
      {
        &quot;name&quot;: &quot;&quot;,
        &quot;type&quot;: &quot;uint256&quot;
      }
    ],
    &quot;payable&quot;: false,
    &quot;stateMutability&quot;: &quot;view&quot;,
    &quot;type&quot;: &quot;function&quot;
  }
]</code></pre>
<p>
然后将其转换为go文件：</p>
<pre><code>abigen --abi token.abi --pkg main --type Token --out token.go</code></pre>
<p>
生成的token.go文件，才是可以被操作的文件。</p>
<pre><code>func TransferToken() {
    key, to_address := CreateWallet()

    client, err := connectRPC()
    if err != nil {
        log.Fatalln(err)
        panic(err)
    }

    auth, err := bind.NewTransactor(strings.NewReader(key), &quot;password&quot;)
    if err != nil {
        log.Fatalln(&quot;读取keystore失败&quot;, err)
        panic(err)
    }

    token, err := cont.NewToken(common.HexToAddress(&quot;0x75a26aaaecda412bd914e8fbfaed586a467fa8b5&quot;), client)
    if err != nil {
        log.Fatalln(&quot;获取token失败&quot;, err)
        panic(err)
    }

    balance, err := token.BalanceOf(nil, common.HexToAddress(to_address))
    if err != nil {
        log.Fatalln(&quot;token balance of&quot;, err)
    }

    log.Println(&quot;to address balance: &quot;, balance)

    amount := big.NewFloat(10.00)
    //这是处理位数的代码段
    tenDecimal := big.NewFloat(math.Pow(10, 18))
    convertAmount, _ := new(big.Float).Mul(tenDecimal, amount).Int(&amp;big.Int{})

    tx, err := token.Transfer(auth, common.HexToAddress(to_address), convertAmount)
    if nil != err {
        fmt.Printf(&quot;err: %v \n&quot;, err)
        return
    }
    fmt.Printf(&quot;result: %v\n&quot;, tx)
}</code></pre>
<blockquote>
  <p>
不知为何会出现failed to estimate gas needed的情况  </p>
</blockquote>
<p>
代币转账的代码就如上所示，有了这个，其实我们就可以发币了。</p>
<p>
至于上面的一句代码中的：</p>
<pre><code>token, err := cont.NewToken(common.HexToAddress(&quot;0x75a26aaaecda412bd914e8fbfaed586a467fa8b5&quot;), client)</code></pre>
<p>
这个<code class="inline">0x75a26aaaecda412bd914e8fbfaed586a467fa8b5</code>地址，就是合约的地址。关于合约的部署，其实如果是在本地调试的话，可以用truffle。truffle在部署的时候，会将合约地址返回。</p>
<p>
如下图所示：</p>
<p>
  <img src="https://ws4.sinaimg.cn/large/0069RVTdgy1fu1f8bx1xvj30xc0m8mzv.jpg" alt="image-20180807203645670" />
</p>
<p>
关于如何在以太坊上写代币的合约，下次再写一下笔记。</p>
<h2>
总结</h2>
<p>
可以用web3去做这些事儿，会更简单一些。因为服务端选型用的go，所以就用go踩了一些坑。</p>

            </article>
        </div>
    </body>
</html>

    