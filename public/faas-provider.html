<html>
    <head>
        <title> 
            faas-provider
        </title>

    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.1.0/build/styles/default.min.css"
    />
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.1.0/build/highlight.min.js"></script>

    <script>
      hljs.highlightAll();
    </script>

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      .markdown-body {
        box-sizing: border-box;
        min-width: 200px;
        max-width: 980px;
        margin: 0 auto;
        padding: 45px;
      }

      @media (max-width: 767px) {
        .markdown-body {
          padding: 15px;
        }
      }
    </style>
    </head>

    <body>
        <div>
            <article class="markdown-body"> 
                <hr class="thin" />
<p>
date: “2018-08-01 19:53:23”
title: faas-provider</p>
<hr class="thin" />
<p>
faas-provider是一个模板，只要实现了这个模板的接口，就可以自定义实现自己的provider。</p>
<h2>
faas-provider</h2>
<p>
OpenFaaS官方提供了两套后台provider：</p>
<ul>
  <li>
Docker Swarm  </li>
  <li>
Kubernetes  </li>
</ul>
<p>
这两者在部署和调用函数的时候流程图如下：</p>
<p>
部署一个函数</p>
<p>
  <img src="https://ws1.sinaimg.cn/large/b831e4c7gy1ftuggjuhtpj20xc07k0x7.jpg" alt="" />
</p>
<p>
调用一个函数</p>
<p>
  <img src="https://ws1.sinaimg.cn/large/b831e4c7gy1ftuggyto07j20xc071n1c.jpg" alt="" />
</p>
<p>
provider要提供的一些API有：</p>
<ul>
  <li>
List / Create / Delete 一个函数  </li>
</ul>
<p>
<code class="inline">/system/functions</code></p>
<p>
方法: GET / POST / DELETE</p>
<ul>
  <li>
获取一个函数  </li>
</ul>
<p>
<code class="inline">/system/function/{name:[-a-zA-Z_0-9]+}</code></p>
<p>
方法: GET</p>
<ul>
  <li>
伸缩一个函数  </li>
</ul>
<p>
<code class="inline">/system/scale-function/{name:[-a-zA-Z_0-9]+}</code></p>
<p>
方法: POST</p>
<ul>
  <li>
调用一个函数  </li>
</ul>
<p>
<code class="inline">/function/{name:[-a-zA-Z_0-9]+}</code></p>
<p>
方法: POST</p>
<p>
在provider的server.go的serve方法，可以看到这个serve方法创建了几个路由，接受一个FaaSHandler对象。</p>
<pre><code>// Serve load your handlers into the correct OpenFaaS route spec. This function is blocking.
func Serve(handlers *types.FaaSHandlers, config *types.FaaSConfig) {
    r.HandleFunc(&quot;/system/functions&quot;, handlers.FunctionReader).Methods(&quot;GET&quot;)
    r.HandleFunc(&quot;/system/functions&quot;, handlers.DeployHandler).Methods(&quot;POST&quot;)
    r.HandleFunc(&quot;/system/functions&quot;, handlers.DeleteHandler).Methods(&quot;DELETE&quot;)
    r.HandleFunc(&quot;/system/functions&quot;, handlers.UpdateHandler).Methods(&quot;PUT&quot;)

    r.HandleFunc(&quot;/system/function/{name:[-a-zA-Z_0-9]+}&quot;, handlers.ReplicaReader).Methods(&quot;GET&quot;)
    r.HandleFunc(&quot;/system/scale-function/{name:[-a-zA-Z_0-9]+}&quot;, handlers.ReplicaUpdater).Methods(&quot;POST&quot;)

    r.HandleFunc(&quot;/function/{name:[-a-zA-Z_0-9]+}&quot;, handlers.FunctionProxy)
    r.HandleFunc(&quot;/function/{name:[-a-zA-Z_0-9]+}/&quot;, handlers.FunctionProxy)

    r.HandleFunc(&quot;/system/info&quot;, handlers.InfoHandler).Methods(&quot;GET&quot;)

    if config.EnableHealth {
        r.HandleFunc(&quot;/healthz&quot;, handlers.Health).Methods(&quot;GET&quot;)
    }
    // 省略
}</code></pre>
<p>
因此在自定义的provider，只需实现FaaSHandlers中的几个路由处理函数即可。这几个handler是：</p>
<pre><code>// FaaSHandlers provide handlers for OpenFaaS
type FaaSHandlers struct {
    FunctionReader http.HandlerFunc
    DeployHandler  http.HandlerFunc
    DeleteHandler  http.HandlerFunc
    ReplicaReader  http.HandlerFunc
    FunctionProxy  http.HandlerFunc
    ReplicaUpdater http.HandlerFunc

    // Optional: Update an existing function
    UpdateHandler http.HandlerFunc
    Health        http.HandlerFunc
    InfoHandler   http.HandlerFunc
}</code></pre>
<p>
我们以官方实现的faas-netes为例，讲解一下这几个hander的实现过程。</p>
<h2>
faas-netes</h2>
<p>
我们看下在faas-netes的中的FaaSHandlers实现：</p>
<pre><code>bootstrapHandlers := bootTypes.FaaSHandlers{
    FunctionProxy:  handlers.MakeProxy(functionNamespace, cfg.ReadTimeout),
    DeleteHandler:  handlers.MakeDeleteHandler(functionNamespace, clientset),
    DeployHandler:  handlers.MakeDeployHandler(functionNamespace, clientset, deployConfig),
    FunctionReader: handlers.MakeFunctionReader(functionNamespace, clientset),
    ReplicaReader:  handlers.MakeReplicaReader(functionNamespace, clientset),
    ReplicaUpdater: handlers.MakeReplicaUpdater(functionNamespace, clientset),
    UpdateHandler:  handlers.MakeUpdateHandler(functionNamespace, clientset),
        Health:         handlers.MakeHealthHandler(),
        InfoHandler:    handlers.MakeInfoHandler(version.BuildVersion(), version.GitCommit),
}</code></pre>
<p>
因为是Kubernetes上的provider实现，所以这些函数都带有一个namespace的参数。</p>
<h3>
FunctionProxy</h3>
<p>
这里最重要的就是FunctionProxy，它主要负责调用函数。这个handler其实也是起到了一个代理转发的作用，在这个函数中，只接受get和post。调用函数只接受post和get请求</p>
<ol>
  <li>
    <p>
创建一个http的client对象    </p>
  </li>
  <li>
    <p>
只处理get和post请求。    </p>
  </li>
  <li>
    <p>
组装代理转发的watchdog的地址    </p>
    <pre><code>url := forwardReq.ToURL(fmt.Sprintf(&quot;%s.%s&quot;, service, functionNamespace), watchdogPort)</code></pre>
    <p>
所以最后请求的格式就会形如：    </p>
    <pre><code>http://函数名.namespace:监视器的端口/路径</code></pre>
  </li>
  <li>
    <p>
将请求发出去    </p>
  </li>
  <li>
    <p>
设置http响应的头    </p>
  </li>
</ol>
<h3>
ReplicaReader和ReplicaUpdater</h3>
<p>
这两个是和副本数相关的，所以放在一起对比讲解。这两个的实现依赖于Kubernetes的客户端，获取代码如下：</p>
<pre><code>clientset, err := kubernetes.NewForConfig(config)</code></pre>
<p>
这个config主要满足以下几个条件就行：</p>
<pre><code>Config{
        // TODO: switch to using cluster DNS.
        Host:            &quot;https://&quot; + net.JoinHostPort(host, port),
        BearerToken:     string(token),
        TLSClientConfig: tlsClientConfig,
}</code></pre>
<p>
Kubernetes的所有操作都可以通过rest api来完成，这两个handler也是通过调用Kubernetes的api来做的。</p>
<h4>
ReplicaReader</h4>
<p>
<code class="inline">MakeReplicaReader</code>函数是获取当前的副本数：</p>
<ol>
  <li>
    <p>
通过mux从路由中获取到name参数    </p>
  </li>
  <li>
    <p>
调用getService方法获取副本数，getService的核心代码就一句：    </p>
    <pre><code>item, err := clientset.ExtensionsV1beta1().Deployments(functionNamespace).Get(functionName, getOpts)</code></pre>
  </li>
  <li>
    <p>
序列化之后，把结果返回    </p>
  </li>
</ol>
<h4>
ReplicaUpdater</h4>
<p>
<code class="inline">MakeReplicaUpdater</code>是解析从gateway传过来的post请求，调用k8s的API设置副本数。</p>
<ol>
  <li>
    <p>
从请求中取出body    </p>
  </li>
  <li>
    <p>
首先获取该函数的已部署的deployment对象    </p>
  </li>
  <li>
    <p>
然后将deployment的副本数量设置为应设数量，这样做的目的是为了仅仅修改副本数，而不修改别的属性。    </p>
    <pre><code>_, err = clientset.ExtensionsV1beta1().Deployments(functionNamespace).Update(deployment)</code></pre>
  </li>
</ol>
<blockquote>
  <p>
注：mux做路由的时候，如果成功的时候不对w做任何处理，是会默认状态码为200，空字符串。  </p>
</blockquote>
<h4>
DeleteHandler，DeployHandler，FunctionReader和UpdateHandler</h4>
<p>
这几个都是对函数的操作，其实就是调用一下Kubernetes的API进行操作。</p>
<p>
这几个是核心的几句代码：</p>
<pre><code>clientset.ExtensionsV1beta1().Deployments(functionNamespace).Delete(request.FunctionName, opts)

deploy := clientset.Extensions().Deployments(functionNamespace)

res, err := clientset.ExtensionsV1beta1().Deployments(functionNamespace).List(listOpts)

_, updateErr := clientset.CoreV1().Services(functionNamespace).Update(service)</code></pre>
<h2>
总结</h2>
<p>
官方还提供了一个faas-swarm，其实现思路也是这样，操作swarm的api来做对容器的操作。至于如何调用一个函数，都是在函数的watchdog中实现。</p>

            </article>
        </div>
    </body>
</html>

    