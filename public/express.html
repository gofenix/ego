<html>
    <head>
        <title> 
            express
        </title>

    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.1.0/build/styles/default.min.css"
    />
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.1.0/build/highlight.min.js"></script>

    <script>
      hljs.highlightAll();
    </script>

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      .markdown-body {
        box-sizing: border-box;
        min-width: 200px;
        max-width: 980px;
        margin: 0 auto;
        padding: 45px;
      }

      @media (max-width: 767px) {
        .markdown-body {
          padding: 15px;
        }
      }
    </style>
    </head>

    <body>
        <div>
            <article class="markdown-body"> 
                <hr class="thin" />
<p>
date: “2018-03-24 17:41:01”
title: express</p>
<hr class="thin" />
<h2>
Express 快速入门</h2>
<h3>
安装</h3>
<pre><code>npm init

npm install --save express</code></pre>
<h3>
hello world</h3>
<pre><code>var express = require(&#39;express&#39;);
var app = express();

app.get(&#39;/&#39;, function (req, res) {
  res.send(&#39;Hello World!&#39;);
});

app.listen(3000, function () {
  console.log(&#39;Example app listening on port 3000!&#39;);
});</code></pre>
<p>
执行命令运行应用程序</p>
<pre><code>node app.js</code></pre>
<p>
然后，在浏览器中输入 <a href="http://localhost:3000/">http://localhost:3000/</a> 以查看输出。</p>
<h2>
express程序生成器</h2>
<h3>
安装</h3>
<pre><code>npm install -g express-generator</code></pre>
<h3>
示例</h3>
<p>
以下语句在当前工作目录中创建名为 <em>myapp</em> 的 Express 应用程序：</p>
<pre><code>express --view=pug myapp</code></pre>
<p>
在 MacOS 或 Linux 上，采用以下命令运行此应用程序：</p>
<pre><code>DEBUG=myapp:* npm start</code></pre>
<p>
然后在浏览器中输入 <code class="inline">http://localhost:3000/</code> 以访问此应用程序。</p>
<h2>
路由</h2>
<h3>
基本路由</h3>
<p>
<em>路由</em>用于确定应用程序如何响应对特定端点的客户机请求，包含一个 URI（或路径）和一个特定的 HTTP 请求方法（GET、POST 等）。</p>
<p>
每个路由可以具有一个或多个处理程序函数，这些函数在路由匹配时执行。</p>
<p>
路由定义采用以下结构：</p>
<pre><code>app.METHOD(PATH, HANDLER)</code></pre>
<p>
其中：</p>
<ul>
  <li>
<code class="inline">app</code> 是 <code class="inline">express</code> 的实例。  </li>
  <li>
<code class="inline">METHOD</code> 是 <a href="http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol">HTTP 请求方法</a>。  </li>
  <li>
<code class="inline">PATH</code> 是服务器上的路径。  </li>
  <li>
<code class="inline">HANDLER</code> 是在路由匹配时执行的函数。  </li>
</ul>
<p>
比如简单的Hello world：</p>
<pre><code>app.get(&#39;/&#39;, function (req, res) {
  res.send(&#39;Hello World!&#39;);
});</code></pre>
<h3>
响应方法</h3>
<p>
下表中响应对象 (<code class="inline">res</code>) 的方法可以向客户机发送响应，并终止请求/响应循环。如果没有从路由处理程序调用其中任何方法，客户机请求将保持挂起状态。</p>
<table>
  <thead>
    <tr>
      <th style="text-align: left;">
方法      </th>
      <th style="text-align: left;">
描述      </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left;">
<a href="http://expressjs.com/zh-cn/4x/api.html#res.download">res.download()</a>      </td>
      <td style="text-align: left;">
提示将要下载文件。      </td>
    </tr>
    <tr>
      <td style="text-align: left;">
<a href="http://expressjs.com/zh-cn/4x/api.html#res.end">res.end()</a>      </td>
      <td style="text-align: left;">
结束响应进程。      </td>
    </tr>
    <tr>
      <td style="text-align: left;">
<a href="http://expressjs.com/zh-cn/4x/api.html#res.json">res.json()</a>      </td>
      <td style="text-align: left;">
发送 JSON 响应。      </td>
    </tr>
    <tr>
      <td style="text-align: left;">
<a href="http://expressjs.com/zh-cn/4x/api.html#res.jsonp">res.jsonp()</a>      </td>
      <td style="text-align: left;">
在 JSONP 的支持下发送 JSON 响应。      </td>
    </tr>
    <tr>
      <td style="text-align: left;">
<a href="http://expressjs.com/zh-cn/4x/api.html#res.redirect">res.redirect()</a>      </td>
      <td style="text-align: left;">
重定向请求。      </td>
    </tr>
    <tr>
      <td style="text-align: left;">
<a href="http://expressjs.com/zh-cn/4x/api.html#res.render">res.render()</a>      </td>
      <td style="text-align: left;">
呈现视图模板。      </td>
    </tr>
    <tr>
      <td style="text-align: left;">
<a href="http://expressjs.com/zh-cn/4x/api.html#res.send">res.send()</a>      </td>
      <td style="text-align: left;">
发送各种类型的响应。      </td>
    </tr>
    <tr>
      <td style="text-align: left;">
<a href="http://expressjs.com/zh-cn/4x/api.html#res.sendFile">res.sendFile</a>      </td>
      <td style="text-align: left;">
以八位元流形式发送文件。      </td>
    </tr>
    <tr>
      <td style="text-align: left;">
<a href="http://expressjs.com/zh-cn/4x/api.html#res.sendStatus">res.sendStatus()</a>      </td>
      <td style="text-align: left;">
设置响应状态码并以响应主体形式发送其字符串表示。      </td>
    </tr>
  </tbody>
</table>
<h3>
app.route()</h3>
<p>
可以使用 <code class="inline">app.route()</code> 为路由路径创建可链接的路由处理程序。 因为在单一位置指定路径，所以可以减少冗余和输入错误。</p>
<pre><code>app.route(&#39;/book&#39;)
  .get(function(req, res) {
    res.send(&#39;Get a random book&#39;);
  })
  .post(function(req, res) {
    res.send(&#39;Add a book&#39;);
  })
  .put(function(req, res) {
    res.send(&#39;Update the book&#39;);
  });</code></pre>
<h3>
express.Router</h3>
<p>
使用 <code class="inline">express.Router</code> 类来创建可安装的模块化路由处理程序。<code class="inline">Router</code> 实例是完整的中间件和路由系统；因此，常常将其称为“微型应用程序”。</p>
<p>
以下示例将路由器创建为模块，在其中装入中间件，定义一些路由，然后安装在主应用程序的路径中。</p>
<p>
在应用程序目录中创建名为 <code class="inline">birds.js</code> 的路由器文件，其中包含以下内容：</p>
<pre><code>var express = require(&#39;express&#39;);
var router = express.Router();

// middleware that is specific to this router
router.use(function timeLog(req, res, next) {
  console.log(&#39;Time: &#39;, Date.now());
  next();
});
// define the home page route
router.get(&#39;/&#39;, function(req, res) {
  res.send(&#39;Birds home page&#39;);
});
// define the about route
router.get(&#39;/about&#39;, function(req, res) {
  res.send(&#39;About birds&#39;);
});

module.exports = router;</code></pre>
<p>
接着，在应用程序中装入路由器模块：</p>
<pre><code>var birds = require(&#39;./birds&#39;);
...
app.use(&#39;/birds&#39;, birds);</code></pre>
<p>
此应用程序现在可处理针对 <code class="inline">/birds</code> 和 <code class="inline">/birds/about</code> 的请求，调用特定于此路由的 <code class="inline">timeLog</code> 中间件函数。</p>
<h2>
中间件</h2>
<p>
<em>中间件</em>函数能够访问<a href="http://expressjs.com/zh-cn/4x/api.html#req">请求对象</a> (<code class="inline">req</code>)、<a href="http://expressjs.com/zh-cn/4x/api.html#res">响应对象</a> (<code class="inline">res</code>) 以及应用程序的请求/响应循环中的下一个中间件函数。下一个中间件函数通常由名为 <code class="inline">next</code> 的变量来表示。</p>
<blockquote>
  <p>
<code class="inline">next()</code> 函数不是 Node.js 或 Express API 的一部分，而是传递给中间件函数的第三自变量。<code class="inline">next()</code> 函数可以命名为任何名称，但是按约定，始终命名为“next”。  </p>
</blockquote>
<p>
中间件函数可以执行以下任务：</p>
<ul>
  <li>
执行任何代码。  </li>
  <li>
对请求和响应对象进行更改。  </li>
  <li>
结束请求/响应循环。  </li>
  <li>
调用堆栈中的下一个中间件。  </li>
</ul>
<p>
如果当前中间件函数没有结束请求/响应循环，那么它必须调用 <code class="inline">next()</code>，以将控制权传递给下一个中间件函数。否则，请求将保持挂起状态。</p>
<p>
Express 应用程序可以使用以下类型的中间件：</p>
<ul>
  <li>
<a href="http://expressjs.com/zh-cn/guide/using-middleware.html#middleware.application">应用层中间件</a>  </li>
  <li>
<a href="http://expressjs.com/zh-cn/guide/using-middleware.html#middleware.router">路由器层中间件</a>  </li>
  <li>
<a href="http://expressjs.com/zh-cn/guide/using-middleware.html#middleware.error-handling">错误处理中间件</a>  </li>
  <li>
<a href="http://expressjs.com/zh-cn/guide/using-middleware.html#middleware.built-in">内置中间件</a>  </li>
  <li>
<a href="http://expressjs.com/zh-cn/guide/using-middleware.html#middleware.third-party">第三方中间件</a>  </li>
</ul>
<h2>
模板引擎</h2>
<p>
在 Express 可以呈现模板文件之前，必须设置以下应用程序设置：</p>
<ul>
  <li>
<code class="inline">views</code>：模板文件所在目录。例如：<code class="inline">app.set(&#39;views&#39;, &#39;./views&#39;)</code>  </li>
  <li>
<code class="inline">view engine</code>：要使用的模板引擎。例如：<code class="inline">app.set(&#39;view engine&#39;, &#39;pug&#39;)</code>  </li>
</ul>
<p>
然后安装对应的模板引擎 npm 包：</p>
<pre><code>npm install pug --save</code></pre>
<p>
在 <code class="inline">views</code> 目录中创建名为 <code class="inline">index.pug</code> 的 Pug 模板文件，其中包含以下内容：</p>
<pre><code>html
  head
    title!= title
  body
    h1!= message</code></pre>
<p>
随后创建路由以呈现 <code class="inline">index.pug</code> 文件。如果未设置 <code class="inline">view engine</code> 属性，必须指定 <code class="inline">view</code> 文件的扩展名。否则，可以将其忽略。</p>
<pre><code>app.get(&#39;/&#39;, function (req, res) {
  res.render(&#39;index&#39;, { title: &#39;Hey&#39;, message: &#39;Hello there!&#39;});
});</code></pre>
<p>
向主页发出请求时，<code class="inline">index.pug</code> 文件将呈现为 HTML。</p>

            </article>
        </div>
    </body>
</html>

    