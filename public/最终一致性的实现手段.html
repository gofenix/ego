<html>
    <head>
        <title> 
            最终一致性的实现手段
        </title>

    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.1.0/build/styles/default.min.css"
    />
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.1.0/build/highlight.min.js"></script>

    <script>
      hljs.highlightAll();
    </script>

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      .markdown-body {
        box-sizing: border-box;
        min-width: 200px;
        max-width: 980px;
        margin: 0 auto;
        padding: 45px;
      }

      @media (max-width: 767px) {
        .markdown-body {
          padding: 15px;
        }
      }
    </style>
    </head>

    <body>
        <div>
            <article class="markdown-body"> 
                <hr class="thin" />
<p>
date: “2018-03-24 18:59:55”
title: 最终一致性的实现手段</p>
<hr class="thin" />
<h1>
最终一致性的实现手段</h1>
<p>
实现最终一致性有三种手段：可靠事件模式、业务补偿模式和TCC模式</p>
<h2>
1 可靠事件模式</h2>
<p>
可靠事件模式属于事件驱动架构，当某件重要的事情发生时，比如更新一个业务实体，微服务会向消息代理发布一个事件。消息代理会将订阅事件的微服务推送事件。</p>
<p>
要实现这种模式需要消息队列实现事件的持久化和at least once的可靠事件投递模式。</p>
<h3>
1.1 本地事件表</h3>
<p>
本地事件表方法是将事件和业务数据保存在同一个数据库中，使用一个额外的事件恢复服务来恢复事件，由本地事物保证更新业务和发布事件的原子性。</p>
<p>
但是业务系统和事件系统耦合比较紧密，额外的事件数据库操作也会给数据库带来额外的压力，可能成为瓶颈。</p>
<h3>
1.2 外部事件</h3>
<p>
此方法是将事件持久化到外部的事件系统，事件系统需要提供实时事件服务以接受微服务发布的事件，同时事件系统还需要提供事件恢复服务来确认恢复事件。</p>
<h3>
1.3 不足</h3>
<p>
此过程可能出现重复消费的情况。</p>
<h2>
2 补偿模式</h2>
<p>
一般来讲，异常一般是由以下两种情况造成的：</p>
<p>
业务异常：业务逻辑产生的错误，比如余额不足、库存不足等。</p>
<p>
技术异常：非业务逻辑产生的异常，比如网络连接异常、超时等。</p>
<p>
补偿模式就是使用一个额外的协调服务来协调各个需要保证一致性的其他服务。协调服务按顺序调用每一个服务，如果某个服务调用异常就取消之前所有已经调用成功的服务。</p>
<p>
建议仅用于技术异常的情况。对于业务异常来讲，应该尽可能的去优化业务模式，以避免要求补偿事务。</p>
<h3>
2.1 常用手段</h3>
<p>
在实现补偿模式时应该做到两点：</p>
<ul>
  <li>
首先要确定失败的步骤和状态，从而确定要补偿的范围。  </li>
  <li>
其次要能提供补偿操作使用的业务数据。  </li>
</ul>
<p>
可以通过记录完整的业务流水的方法来实现上面两点要求。但是对于一个通用的补偿框架来说，预先知道微服务需要记录的业务要素是不可能的，那么就需要一种办法来保证业务流水的可扩展性，实践中主要有两种方法：大表和关联表。</p>
<ul>
  <li>
大表，顾明思议就是设计时除了必须的字段外，还需要预留大量的备用字段，框架可以提供辅助工具来将业务数据映射到备用字段中。大表对于框架层实现起来比较简单，但是也有一些难点，比如预留多少个字段合适，每个字段又需要预留多长。还有一个难点是如果仅从数据层面来查询数据，很难一眼看出备用字段的业务含义，维护过程不友好。  </li>
  <li>
关联表，分为技术表和业务表。技术表中保存为实现补偿操作所需要的技术数据，业务表中保存业务数据。通过在技术表中增加业务表名和业务表主键来建立和业务数据的关联。关联表更灵活，能支持不同业务类型记录不同的业务要素。但是在框架的实现上难度较高，每次查询都需要复杂的关联动作，性能会受到影响。  </li>
</ul>
<h3>
2.2 重试</h3>
<p>
补偿过程作为一个服务，在调用的时候也会出现不成功的情况，这时就要通过重试机制来保证补偿的成功率。因此要求补偿操作具有幂等性。</p>
<p>
但是也不是盲目的重试，我们需要根据服务执行失败的原因来选择不同的策略：</p>
<ul>
  <li>
因业务因素导致失败，需要停止重试。  </li>
  <li>
罕见的异常，如网络中断，传输过程中数据丢失，应该立即重试。  </li>
  <li>
如果是因为系统繁忙，此时需要等待一段时间再重试。  </li>
</ul>
<h3>
2.3 不足</h3>
<p>
在补偿模式中有一个明显的缺陷是隔离性，从第一个服务开始一直到补偿完成，不一致性是对其他服务可见的。另外补偿模式过分依赖协调服务的健壮性，如果协调服务异常，则没办法达到一致性。</p>
<h2>
3 TCC模式</h2>
<p>
TCC，是Try，Confirm和Cancel的缩写。一个完整的TCC业务一般是由一个主业务和若干个从业务组成。</p>
<ul>
  <li>
Try    <ul>
      <li>
完成所有业务检查      </li>
      <li>
预留必须的业务资源      </li>
    </ul>
  </li>
  <li>
Confirm    <ul>
      <li>
真正执行业务      </li>
      <li>
不做任何业务检查      </li>
      <li>
只使用Try阶段预留的业务资源      </li>
      <li>
满足幂等性      </li>
    </ul>
  </li>
  <li>
Cancel    <ul>
      <li>
释放Try阶段预留的业务资源      </li>
      <li>
满足幂等性      </li>
    </ul>
  </li>
</ul>
<h3>
3.1 实现过程</h3>
<p>
整个TCC业务分成两个阶段完成：</p>
<p>
第一阶段：主业务服务分别调用所有从业务的try操作，并在活动管理器中登记所有从业务服务。当所有从业务服务的try操作都调用成功或者某个从业务服务的try操作失败，进入第二阶段。</p>
<p>
第二阶段：活动管理器根据第一阶段的执行结果来执行Confirm或Cancel操作。如果第一阶段所有的try操作是成功的，则调用所有从业务的Confirm操作，否则都调用Cancel操作。</p>
<p>
TCC模式不再需要记录详细的业务流水，在一定程度上弥补了补偿模式的缺陷，在TCC模式中，直到明确的Confirm动作，所有的业务操作都是隔离的。而且还可以通过指定try的超时时间，主动的Cancel预留的资源，从而实现了自治。</p>
<h3>
3.2 不足</h3>
<p>
TCC模式不能百分百保证一致性，如果某服务提交了Confirm成功，但是由于网络故障，导致主服务收到的失败，那么就会出现不一致性，这被称为heuristic exception。因此为保证成功率，都需要支持重试。</p>
<p>
heuristic exception是不可杜绝的，但是通过设置合理的超时时间、重试频率以及监控，可以使此异常的可能性降到很低，另外如果出现了此异常，还可通过人工手段补救。</p>

            </article>
        </div>
    </body>
</html>

    