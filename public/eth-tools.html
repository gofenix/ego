<html>
    <head>
        <title> 
            eth-tools
        </title>

    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.1.0/build/styles/default.min.css"
    />
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.1.0/build/highlight.min.js"></script>

    <script>
      hljs.highlightAll();
    </script>

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      .markdown-body {
        box-sizing: border-box;
        min-width: 200px;
        max-width: 980px;
        margin: 0 auto;
        padding: 45px;
      }

      @media (max-width: 767px) {
        .markdown-body {
          padding: 15px;
        }
      }
    </style>
    </head>

    <body>
        <div>
            <article class="markdown-body"> 
                <hr class="thin" />
<p>
date: “2018-08-10 18:57:09”
title: 以太坊开发总结</p>
<hr class="thin" />
<p>
最近因公司项目需要，做为一个打杂工程师，操起键盘和笔记本开始了以太坊的踩坑之旅。以太坊的开发比较新，变化也比较多，还好有<a href="https://github.com/cctanfujun">@cctanfujun</a>的手把手带领下，半只脚踏入了以太坊的开发的大门。</p>
<p>
在这篇文章中，我将会简单介绍一下以太坊的基本概念，以及我现在用到的一些工具，还有具体的一个开发流程。因为我还没有接触到如何上主链，所以这些都是基于测试链讲解。希望能给大家带来一些帮助。</p>
<p>
什么是区块链</p>
<p>
相信大家对区块链都有自己的理解，不仅仅是互联网公司，传统企业也在“币改转型”。</p>
<p>
<strong>简言之，区块链就是数据库。</strong>它是特定数据的数据库，里面的数据不断增长，具有非凡特性：</p>
<ol>
  <li>
一旦数据存储于数据库，永远都无法被修改或删除。区块链上的每个记录会被永久保存下来。  </li>
  <li>
没有单独的个人或组织能维护该数据库。必须要上千个人才行，每个人都有数据库的副本。  </li>
</ol>
<p>
什么是以太坊？</p>
<blockquote>
  <p>
<strong>以太坊</strong>（英语：Ethereum）是一个<a href="https://zh.wikipedia.org/wiki/%E5%BC%80%E6%BA%90">开源</a>的有<a href="https://zh.wikipedia.org/wiki/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6">智能合约</a>功能的公共<a href="https://zh.wikipedia.org/wiki/%E5%8C%BA%E5%9D%97%E9%93%BE">区块链</a>平台[<a href="https://zh.wikipedia.org/wiki/%E4%BB%A5%E5%A4%AA%E5%9D%8A#cite_note-Gray-2014-04-07-1">1]</a>[<a href="https://zh.wikipedia.org/wiki/%E4%BB%A5%E5%A4%AA%E5%9D%8A#cite_note-Vigna-28-Oct-2015-2">2]</a>。通过其专用<a href="https://zh.wikipedia.org/wiki/%E5%8A%A0%E5%AF%86%E8%B4%A7%E5%B8%81">加密货币</a><a href="https://zh.wikipedia.org/wiki/%E4%BB%A5%E5%A4%AA%E5%B8%81">以太币</a>（Ether，又称“以太币”）提供<a href="https://zh.wikipedia.org/wiki/%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96">去中心化</a>的<a href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E6%9C%BA">虚拟机</a>（称为“以太虚拟机”Ethereum Virtual Machine）来处理<a href="https://zh.wikipedia.org/wiki/%E7%82%B9%E5%AF%B9%E7%82%B9">点对点</a>合约。  </p>
</blockquote>
<p>
为什么选择以太坊？</p>
<ul>
  <li>
    <p>
智能合约    </p>
  </li>
  <li>
    <p>
代币    </p>
  </li>
  <li>
    <p>
资料相对完善，相对容易开发    </p>
  </li>
  <li>
    <p>
大佬对以太坊比较熟悉    </p>
  </li>
  <li>
    <p>
大佬对以太坊比较熟悉    </p>
  </li>
  <li>
    <p>
大佬对以太坊比较熟悉    </p>
  </li>
</ul>
<p>
重要的事情说三遍，有一个经验丰富的人带领，做东西肯定事半功倍。</p>
<p>
自己动手写区块链</p>
<p>
这里提供两个教程，一个是书，一个是视频。其中视频和书是对应的，不清楚是不是同一个作者。</p>
<p>
<a href="https://github.com/liuchengxu/blockchain-tutorial">Blockchain Tutorial</a></p>
<p>
<a href="https://www.imooc.com/learn/1021?mc_marking=cfb7fb7f097d2fca6dabbe4c5e71cf77&mc_channel=syb38">私有区块链，我们一起GO</a></p>
<p>
以太坊开发</p>
<p>
由于我是专注于后端的开发，现在的技术栈是</p>
<ul>
  <li>
node  </li>
  <li>
go  </li>
</ul>
<p>
正式进入以太坊的开发。这是我这段时间接触到的一些资源：</p>
<ul>
  <li>
    <p>
go-ethereum：也就是geth，官方的go版本的客户端    </p>
  </li>
  <li>
    <p>
solidity：智能合约编程语言    </p>
  </li>
  <li>
    <p>
truffle：智能合约的编程框架，基于nodejs    </p>
  </li>
  <li>
    <p>
Ganache：启动了多个节点本地私链    </p>
  </li>
  <li>
    <p>
Rinkeby：以太坊测试链    </p>
  </li>
  <li>
    <p>
Etherscan：以太坊区块链浏览器，可以查询交易    </p>
  </li>
  <li>
    <p>
MetaMask：chrome的钱包插件    </p>
  </li>
  <li>
    <p>
web3：官方封装的开发Dapp的库，可以调用合约    </p>
  </li>
  <li>
    <p>
truffle-hdwallet-provider：web3的确定性钱包provider    </p>
  </li>
</ul>
<p>
概念</p>
<p>
账户和钱包</p>
<p>
在以太坊中，一个账号就是一个地址（address），里面有余额。</p>
<p>
钱包是保管私钥的地址， 私钥-&gt;公钥-&gt;地址   这是一个一一对应的关系，钱包里面可以有多个账户。</p>
<p>
私钥不同的生成方法，对应着不同的钱包结构，因此分为了确定性钱包和非确定性钱包。</p>
<ul>
  <li>
比特币最早的客户端（Satoshi client）就是非确定性钱包，钱包是一堆随机生成的私钥的集合。 客户端会预先生成 100 个随机私钥，并且每个私钥只使用一次。  </li>
  <li>
确定性钱包则不需要每次转账都要备份，确定性钱包的私钥是对种子进行单向哈希运算生成的，种子是一串由随机数生成器生成的随机数。在确定性钱包中，只要有这个种子，就可以找回所有私钥  </li>
</ul>
<p>
HD 钱包是目前常用的确定性钱包 ，说到 HD 钱包，大家可能第一反应会想到硬件钱包 （Hardware Wallet），其实这里的 HD 是 Hierarchical Deterministic（分层确定性）的缩写。</p>
<blockquote>
  <p>
所谓分层，就是一个大公司可以为每个子部门分别生成不同的私钥，子部门还可以再管理子子部门的私钥，每个部门可以看到所有子部门里的币，也可以花这里面的币。也可以只给会计人员某个层级的公钥，让他可以看见这个部门及子部门的收支记录，但不能花里面的钱，使得财务管理更方便了。  </p>
</blockquote>
<p>
生成规则是：</p>
<ol>
  <li>
生成一个助记词（参见 BIP39）  </li>
  <li>
该助记词使用 PBKDF2 转化为种子（参见 BIP39）  </li>
  <li>
种子用于使用 HMAC-SHA512 生成根私钥（参见 BIP32）  </li>
  <li>
从该根私钥，导出子私钥（参见 BIP32），其中节点布局由BIP44设置  </li>
</ol>
<p>
DAPP</p>
<p>
以太坊与其他加密货币的主要不同在于，以太坊不是单纯的货币，而是一个环境/平台。在这个平台上，任何人都可以利用区块链的技术，通过智能合约来构建自己的项目和DAPPS（去中心化应用）。DAPPS发布的方式通常是采用被称为“ICO”的众筹方式。简单来说，你需要用你的以太来购买相应DAPP的一些tokens。</p>
<p>
代币</p>
<p>
为什么不能在这些DAPPS中直接使用以太完成交易？为什么我们需要给DAPPS创造一种原生的货币？</p>
<p>
因为即使在现实生活中，我们也在使用某种形式的Token来代替现金。比如：在游乐场里，你先用现金兑换代币，然后用代币来支付各种服务。在这个例子中，现金就是以太，代币就是token。</p>
<p>
ERC20：以太坊token标准</p>
<p>
简单来说，ERC20是开发者在自己的tokens中必须采用的一套具体的公式/方法，从而确保该token与ERC20兼容。在合约执行过程中，下面的四个行为是ERC20 tokens所需要完成的：</p>
<ul>
  <li>
获得Token供给总量.  </li>
  <li>
获得账户余额.  </li>
  <li>
从一方向另一方转移Token.  </li>
  <li>
认可Token作为货币性资产的使用.  </li>
</ul>
<p>
大佬说：代币其实就是智能合约，而这个合约是发生了0个以太的转账。</p>
<p>
Gas和挖矿</p>
<p>
不少小哥哥或小姐姐会认为挖矿就是挖以太币，其实代币不用挖的，当你挖到了区块，代币是给你的奖励。因为任何一笔交易都需要记录，一个区块的大小也就几M，存储不了那么多交易信息，所以要持续挖区块来记录交易，同时只要是你发起了交易，就得付手续费，这些手续费也成为Gas，会按照一定的算法奖励给挖出区块的人。</p>
<p>
接下来会讲一下，平时开发中如何创建钱包，如何转账，如何自己发代币，如何部署合约并调用。</p>
<p>
环境准备</p>
<ul>
  <li>
安装Ganache并启动  </li>
  <li>
安装truffle框架  </li>
</ul>
<p>
创建钱包</p>
<p>
golang</p>
<p>
依赖</p>
<pre><code>github.com/ethereum/go-ethereum</code></pre>
<p>
首先要连接到测试链，测试链可以是本地的也可以是公网的。</p>
<pre><code>func connectRPC() (*ethclient.Client, error) {
    // 连接测试链的节点
    //rpcClient, err := rpc.Dial(&quot;https://rinkeby.infura.io/v3/6c81fb1b66804f0698d49f2ec242afc9&quot;)
    rpcClient, err := rpc.Dial(&quot;http://127.0.0.1:7545&quot;)
    if err != nil {
        log.Fatalln(err)
        return nil, err
    }

    conn := ethclient.NewClient(rpcClient)
    return conn, nil
}</code></pre>
<p>
一般都选择以keystore的形式创建账户</p>
<pre><code>func CreateWallet() (key, addr string) {
    ks := keystore.NewKeyStore(&quot;~/Documents/github/gowork/src/geth-demo/&quot;,
        keystore.StandardScryptN, keystore.StandardScryptP)
    account, _ := ks.NewAccount(&quot;password&quot;)
    key_json, err := ks.Export(account, &quot;password&quot;, &quot;password&quot;)
    if err != nil {
        log.Fatalln(&quot;导出账户错误: &quot;, err)
        panic(err)
    }
    key = string(key_json)
    addr = account.Address.Hex()
    return
}</code></pre>
<p>
当然另一种创建账户的方式是用私钥：</p>
<pre><code>func CreateWallet() (string, error) {
    key, err := crypto.GenerateKey()
    if err != nil {
        log.Fatalln(err)
        return &quot;&quot;, nil
    }

    address := crypto.PubkeyToAddress(key.PublicKey).Hex()
    log.Println(&quot;address: &quot;, address)

    privateKey := hex.EncodeToString(key.D.Bytes())
    log.Println(&quot;privateKey: &quot;, privateKey)
    return address, nil
}</code></pre>
<p>
Node</p>
<p>
node一般使用web3。创建web3对象的时候要使用一个provider，这个provider用来连接到测试链，可以是钱包的，也可以是一个HttpProvider。</p>
<p>
创建web3</p>
<pre><code>const web3 = new Web3(new Web3.providers.HttpProvider(&quot;http://localhost:7545&quot;));</code></pre>
<p>
或者使用<code class="inline">truffle-hdwallet-provider</code>来创建，使用这个的前提是，自己已经创建了一个钱包，并且这个钱包是HD的。</p>
<pre><code>const Web3 = require(&#39;web3&#39;);
const HDWalletProvider = require(&#39;truffle-hdwallet-provider&#39;);

const provider = new HDWalletProvider(助记词, 测试链url);
const web3 = new Web3(provider);</code></pre>
<p>
创建账户</p>
<pre><code></code></pre>

            </article>
        </div>
    </body>
</html>

    