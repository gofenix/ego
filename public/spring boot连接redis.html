<html>
    <head>
        <title> 
            spring boot连接redis
        </title>

    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.1.0/build/styles/default.min.css"
    />
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.1.0/build/highlight.min.js"></script>

    <script>
      hljs.highlightAll();
    </script>

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      .markdown-body {
        box-sizing: border-box;
        min-width: 200px;
        max-width: 980px;
        margin: 0 auto;
        padding: 45px;
      }

      @media (max-width: 767px) {
        .markdown-body {
          padding: 15px;
        }
      }
    </style>
    </head>

    <body>
        <div>
            <article class="markdown-body"> 
                <hr class="thin" />
<p>
date: “2018-03-24 19:00:48”
title: spring boot连接redis</p>
<hr class="thin" />
<p>
<strong>Spring-data-redis</strong>为spring-data模块中对redis的支持部分，简称为“SDR”，提供了基于jedis客户端API的高度封装以及与spring容器的整合，</p>
<p>
jedis客户端在编程实施方面存在如下不足：</p>
<ul>
  <li>
connection管理缺乏自动化，connection-pool的设计缺少必要的容器支持。  </li>
  <li>
数据操作需要关注“序列化”/“反序列化”，因为jedis的客户端API接受的数据类型为string和byte，对结构化数据(json,xml,pojo等)操作需要额外的支持。  </li>
  <li>
事务操作纯粹为硬编码  </li>
  <li>
pub/sub功能，缺乏必要的设计模式支持，对于开发者而言需要关注的太多。  </li>
</ul>
<h2>
1 spring-data-redis特性</h2>
<ol>
  <li>
连接池自动管理，提供了一个高度封装的“RedisTemplate”类  </li>
  <li>
针对jedis客户端中大量api进行了归类封装,将同一类型操作封装为operation接口    <ul>
      <li>
<code class="inline">ValueOperations</code>：简单K-V操作      </li>
      <li>
<code class="inline">SetOperations</code>：set类型数据操作      </li>
      <li>
<code class="inline">ZSetOperations</code>：zset类型数据操作      </li>
      <li>
<code class="inline">HashOperations</code>：针对map类型的数据操作      </li>
      <li>
<code class="inline">ListOperations</code>：针对list类型的数据操作      </li>
    </ul>
  </li>
  <li>
提供了对key的“bound”(绑定)便捷化操作API，可以通过bound封装指定的key，然后进行一系列的操作而无须“显式”的再次指定Key，即BoundKeyOperations：    <ul>
      <li>
<code class="inline">BoundValueOperations</code>      </li>
      <li>
<code class="inline">BoundSetOperations</code>      </li>
      <li>
<code class="inline">BoundListOperations</code>      </li>
      <li>
<code class="inline">BoundSetOperations</code>      </li>
      <li>
<code class="inline">BoundHashOperations</code>      </li>
    </ul>
  </li>
  <li>
将事务操作封装，有容器控制。  </li>
  <li>
针对数据的“序列化/反序列化”，提供了多种可选择策略(RedisSerializer)    <ul>
      <li>
<code class="inline">JdkSerializationRedisSerializer</code>：POJO对象的存取场景，使用JDK本身序列化机制，将pojo类通过ObjectInputStream/ObjectOutputStream进行序列化操作，最终redis-server中将存储字节序列。是目前最常用的序列化策略。      </li>
      <li>
<code class="inline">StringRedisSerializer</code>：Key或者value为字符串的场景，根据指定的charset对数据的字节序列编码成string，是“new String(bytes, charset)”和“string.getBytes(charset)”的直接封装。是最轻量级和高效的策略。      </li>
      <li>
<code class="inline">JacksonJsonRedisSerializer</code>：jackson-json工具提供了javabean与json之间的转换能力，可以将pojo实例序列化成json格式存储在redis中，也可以将json格式的数据转换成pojo实例。因为jackson工具在序列化和反序列化时，需要明确指定Class类型，因此此策略封装起来稍微复杂。      </li>
      <li>
<code class="inline">OxmSerializer</code>：提供了将javabean与xml之间的转换能力，目前可用的三方支持包括jaxb，apache-xmlbeans；redis存储的数据将是xml工具。不过使用此策略，编程将会有些难度，而且效率最低；不建议使用。      </li>
    </ul>
  </li>
  <li>
基于设计模式，和JMS开发思路，将pub/sub的API设计进行了封装，使开发更加便捷。  </li>
  <li>
spring-data-redis中，并没有对sharding提供良好的封装，如果你的架构是基于sharding，那么你需要自己去实现，这也是sdr和jedis相比，唯一缺少的特性。  </li>
</ol>
<h2>
2 引入依赖</h2>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
<h2>
3 配置</h2>
<pre><code class="properties"># REDIS (RedisProperties)
# Redis数据库索引（默认为0）
spring.redis.database=0
# Redis服务器地址
spring.redis.host=localhost
# Redis服务器连接端口
spring.redis.port=6379
# Redis服务器连接密码（默认为空）
spring.redis.password=root
# 连接池最大连接数（使用负值表示没有限制）
spring.redis.pool.max-active=8
# 连接池最大阻塞等待时间（使用负值表示没有限制）
spring.redis.pool.max-wait=-1
# 连接池中的最大空闲连接
spring.redis.pool.max-idle=8
# 连接池中的最小空闲连接
spring.redis.pool.min-idle=0
# 连接超时时间（毫秒）
spring.redis.timeout=0</code></pre>
<p>
其中spring.redis.database的配置通常使用0即可，Redis在配置的时候可以设置数据库数量，默认为16，可以理解为数据库的schema</p>
<h3>
3.1 <code class="inline">StringRedisTemplate</code></h3>
<pre><code>@RunWith(SpringRunner.class)
@SpringBootTest
public class DemoApplicationTests {

    @Autowired
    private StringRedisTemplate stringRedisTemplate;

    @Test
    public void testRedis(){
        stringRedisTemplate.opsForValue().set(&quot;myKey&quot;, &quot;hello redis&quot;);
        Assert.assertEquals(&quot;hello redis&quot;, stringRedisTemplate.opsForValue().get(&quot;myKey&quot;));
    }

}</code></pre>
<p>
通过上面这段极为简单的测试案例演示了如何通过自动配置的StringRedisTemplate对象进行Redis的读写操作，该对象从命名中就可注意到支持的是String类型。如果有使用过spring-data-redis的开发者一定熟悉RedisTemplate&lt;K, V&gt;接口，StringRedisTemplate就相当于RedisTemplate&lt;String, String&gt;的实现。</p>
<p>
除了String类型，我们还经常会在Redis中存储对象。</p>
<h3>
3.2 <code class="inline">RedisTemplate&lt;Object, Object&gt;</code></h3>
<h4>
3.2.1 新建User类</h4>
<pre><code>@Data
@AllArgsConstructor
public class User implements Serializable{
    private static final long serialVersionUID = 1L;
    private Integer id;
    private String username;
    private Integer age;
}</code></pre>
<h4>
3.2.2 创建UserRepository</h4>
<pre><code>@Repository
public class UserRepository {
    @Autowired
    private RedisTemplate&lt;Object, Object&gt; redisTemplate;

    //
    @Resource(name = &quot;redisTemplate&quot;)
    ValueOperations&lt;Object, Object&gt; valOps;

    /**
     * 保存
     * @param user
     */
    public void save(User user) {
        int id = user.getId();
        valOps.set(id, user);
    }

    /**
     * 获取
     * @param id
     * @return
     */
    public User getUserById(int id) {
        return (User) valOps.get(id);
    }

}</code></pre>
<p>
@Resource注解和@Autowired一样，也可以标注在字段或属性的setter方法上，但它默认按名称装配。名称可以通过@Resource的name属性指定，如果没有指定name属性，当注解标注在字段上，即默认取字段的名称作为bean名称寻找依赖对象，当注解标注在属性的setter方法上，即默认取属性名作为bean名称寻找依赖对象。</p>
<h4>
3.2.3 单元测试</h4>
<pre><code>@RunWith(SpringRunner.class)
@SpringBootTest
public class DemoApplicationTests {
    @Autowired
    private UserRepository userRepository;

    @Test
    public void testRedis(){
        User user=new User(1, &quot;hello&quot;, 12);
        userRepository.save(user);
        Assert.assertEquals(&quot;hello&quot;, userRepository.getUserById(1).getUsername());
    }
}</code></pre>
<h2>
4 参考资料</h2>
<p>
<a href="http://blog.csdn.net/smartdt/article/details/78894013">SpringBoot之Redis的支持</a></p>
<p>
<a href="http://shift-alt-ctrl.iteye.com/blog/1886831">Spring-data-redis特性与实例</a></p>

            </article>
        </div>
    </body>
</html>

    