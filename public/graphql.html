<html>
    <head>
        <title> 
            graphql
        </title>

    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.1.0/build/styles/default.min.css"
    />
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.1.0/build/highlight.min.js"></script>

    <script>
      hljs.highlightAll();
    </script>

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      .markdown-body {
        box-sizing: border-box;
        min-width: 200px;
        max-width: 980px;
        margin: 0 auto;
        padding: 45px;
      }

      @media (max-width: 767px) {
        .markdown-body {
          padding: 15px;
        }
      }
    </style>
    </head>

    <body>
        <div>
            <article class="markdown-body"> 
                <hr class="thin" />
<p>
date: “2018-11-08 18:28:13”
title: graphql</p>
<hr class="thin" />
<p>
graphql经常被认为是聚焦于前端的技术。</p>
<h1>
核心概念</h1>
<h2>
SDL：schema definition language（模式定义语言）</h2>
<p>
如：</p>
<pre><code class="typescript">type Person{
    name: String!
    age: Int!
}</code></pre>
<p>
这个类型有两个字段，name和age，他们的类型是String和Int。！的意思代表他们是必需的。</p>
<pre><code class="typescript">type Post{
    title: String!
    author: Person!
}</code></pre>
<p>
接下来的Post也有两个字段，其中Person也是可以作为一个类型。</p>
<p>
也可以这样，在Person中添加一个post：</p>
<pre><code class="tsx">type Person{
    name: String!
    age: Int!
    posts: [Post!]!
}</code></pre>
<h2>
通过Query获取数据</h2>
<h3>
基本查询</h3>
<p>
客户端发送下面的数据给服务器</p>
<pre><code class="typescript">{
    allPersons {
        name
    }
}</code></pre>
<p>
allPersons是根字段（root field），它下面的成为查询的payload，这里仅包含了一个name。</p>
<p>
服务器返回的结果会是这样的：</p>
<pre><code class="tsx">{
    &quot;allPersons&quot;: [
        { &quot;name&quot;: &quot;Johnny&quot; },
        { &quot;name&quot;: &quot;Sarah&quot; },
        { &quot;name&quot;: &quot;Alice&quot; }
    ]
}</code></pre>
<p>
可以看到只返回了name字段，age字段是不会返回的。</p>
<p>
如果使用如下的payload就会返回：</p>
<pre><code class="tsx">{
    allPersons {
        name
        age
    }
}</code></pre>
<p>
还可以查询posts中的title：</p>
<pre><code>{
  allPersons {
    name
    age
    posts {
      title
    }
  }
}</code></pre>
<h3>
带参数查询</h3>
<p>
在graphql中每个字段都有0或者更多个参数。比如allPerson有一个last参数，只返回最后两个人的信息，这里就是查询的语句：</p>
<pre><code>{
  allPersons(last: 2) {
    name
  }
}</code></pre>
<h2>
通过Mutation写数据</h2>
<ul>
  <li>
创建  </li>
  <li>
更新  </li>
  <li>
删除  </li>
</ul>
<p>
mutation和query类似，只是需要加上mutation关键字。如：</p>
<pre><code class="tsx">mutation {
  createPerson(name: &quot;Bob&quot;, age: 36) {
    name
    age
  }
}</code></pre>
<p>
mutation也有一个根字段，叫createPerson。我们知道这个字段有两个参数name和age。返回值会像这样：</p>
<pre><code class="tsx">{
  &quot;data&quot;: {
    &quot;createPerson&quot;: {
      &quot;name&quot;: &quot;Bob&quot;,
      &quot;age&quot;: 36
    }
  }
}</code></pre>
<p>
graphql会给每个记录新增一个唯一的ID字段，我们也可以这样设置Person类型：</p>
<pre><code class="tsx">type Person {
  id: ID!
  name: String!
  age: Int!
}</code></pre>
<p>
然后当一个新的Person对象创建时，就可以访问到id。</p>
<h2>
通过订阅实时更新</h2>
<p>
graphql提供了实时订阅更新。</p>
<p>
当客户端订阅一个事件的时候，将会保持一个和服务器的稳定连接，当有变化时会告诉客户端。</p>
<pre><code class="ts">subscription {
  newPerson {
    name
    age
  }
}</code></pre>
<p>
因此当有个用户创建或者修改时都会告诉客户端：</p>
<pre><code>{
  &quot;newPerson&quot;: {
    &quot;name&quot;: &quot;Jane&quot;,
    &quot;age&quot;: 23
  }
}</code></pre>
<h2>
定义一个模式</h2>
<p>
有几个特殊的根类型：</p>
<pre><code class="ts">type Query { ... }
type Mutation { ... }
type Subscription { ... }</code></pre>
<p>
API的根字段都是在上面这三个之下，如：</p>
<pre><code class="ts">type Query {
  allPersons: [Person!]!
}</code></pre>
<p>
allPersons也可以有参数：</p>
<pre><code class="ts">type Query {
  allPersons(last: Int): [Person!]!
}</code></pre>
<p>
类似的mutation也是：</p>
<pre><code class="ts">type Mutation {
  createPerson(name: String!, age: Int!): Person!
}</code></pre>
<p>
订阅也是：</p>
<pre><code class="ts">type Subscription {
  newPerson: Person!
}</code></pre>
<p>
把他们放在一起就是：</p>
<pre><code class="ts">type Query {
  allPersons(last: Int): [Person!]!
}

type Mutation {
  createPerson(name: String!, age: Int!): Person!
}

type Subscription {
  newPerson: Person!
}

type Person {
  name: String!
  age: Int!
  posts: [Post!]!
}

type Post {
  title: String!
  author: Person!
}</code></pre>
<h2>
架构图</h2>
<p>
graphql直连数据库</p>
<p>
  <img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fx0v777rc9j30lr0573yq.jpg" alt="" />
</p>
<p>
graphql连接层连接多个服务</p>
<p>
  <img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fx0v7pe3qkj30p60j2t9u.jpg" alt="" />
</p>
<p>
graphql混连数据库和服务</p>
<p>
  <img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fx0v867hy3j30k30jrwff.jpg" alt="" />
</p>
<h2>
解析函数</h2>
<p>
每个字段其实都有一个解析器，叫resolver。</p>
<p>
当服务器收到一个请求时，会调用字段的resolver函数，一旦resolver函数有返回，服务器就会把数据包装成要返回的字段。</p>
<p>
有这样一个类型：</p>
<pre><code class="ts">type Query {
  author(id: ID!): Author
}

type Author {
  posts: [Post]
}

type Post {
  title: String
  content: String
}</code></pre>
<p>
当执行一个query的时候：</p>
<pre><code class="ts">query {
  author(id: &quot;abc&quot;) {
    posts {
      title
      content
    }
  }
}</code></pre>
<p>
会以如下的方式执行：</p>
<pre><code class="ts">Query.author(root, { id: &#39;abc&#39; }, context) -&gt; author
Author.posts(author, null, context) -&gt; posts
for each post in posts
  Post.title(post, null, context) -&gt; title
  Post.content(post, null, context) -&gt; content</code></pre>
<h1>
实战</h1>

            </article>
        </div>
    </body>
</html>

    