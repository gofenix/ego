<html>
    <head>
        <title> 
            openfaas-workshop-lab4
        </title>

    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.1.0/build/styles/default.min.css"
    />
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.1.0/build/highlight.min.js"></script>

    <script>
      hljs.highlightAll();
    </script>

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      .markdown-body {
        box-sizing: border-box;
        min-width: 200px;
        max-width: 980px;
        margin: 0 auto;
        padding: 45px;
      }

      @media (max-width: 767px) {
        .markdown-body {
          padding: 15px;
        }
      }
    </style>
    </head>

    <body>
        <div>
            <article class="markdown-body"> 
                <hr class="thin" />
<p>
date: “2018-07-02 09:32:59”
title: openfaas-workshop-lab4</p>
<hr class="thin" />
<h1>
Lab 4 - 深入函数</h1>
<img src="https://github.com/openfaas/media/raw/master/OpenFaaS_Magnet_3_1_png.png" width="500px" />
<p>
在开始本实验之前，创建一个新的文件夹，把 lab3 的文件拷贝到 lab4 里：</p>
<pre><code>$ cp -r lab3 lab4 \
   &amp;&amp; cd lab4</code></pre>
<h2>
通过环境变量注入配置</h2>
<p>
It is useful to be able to control how a function behaves at runtime, we can do that in at least two ways:</p>
<p>
控制函数在运行时的行为很有用，我们至少可以通过两种方式来实现：</p>
<h3>
在部署时</h3>
<ul>
  <li>
在部署时设置环境变量  </li>
</ul>
<p>
我们在 Lab3 时用了 write_debug 来做——你也可以在这里设置你想要的任何自定义的环境变量。例如：如果你想为 hello world 函数配置一种语言，可以引入一个 spoken_language 变量。</p>
<h3>
使用 HTTP 上下文——querystring / headers</h3>
<ul>
  <li>
使用 querystring 和 HTTP headers  </li>
</ul>
<p>
另一个更为动态的选项是可以在每个请求级别上进行修改，即使用 querystrings 和 HTTP headers，这两者都可以通过 faas-cli 或者 curl 传递。</p>
<p>
这些 headers 通过环境变量暴露出来，因此你可以很容易的在函数中使用。所有的 header 都以 Http<em>为前缀，并且所有的<code class="inline">-</code>都被替换为了` </em> `下划线</p>
<p>
让我们用一个 querystring 和一个列出所有环境变量的函数来尝试一下：</p>
<ul>
  <li>
部署一个函数，此函数使用内置的 BusyBox 命令来打印环境变量  </li>
</ul>
<pre><code>$ faas-cli deploy --name env --fprocess=&quot;env&quot; --image=&quot;functions/alpine:latest&quot; --network=func_functions</code></pre>
<ul>
  <li>
用一个 querystring 去调用函数：  </li>
</ul>
<pre><code>$ echo &quot;&quot; | faas-cli invoke env --query workshop=1
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
HOSTNAME=05e8db360c5a
fprocess=env
HOME=/root
Http_Connection=close
Http_Content_Type=text/plain
Http_X_Call_Id=cdbed396-a20a-43fe-9123-1d5a122c976d
Http_X_Forwarded_For=10.255.0.2
Http_X_Start_Time=1519729562486546741
Http_User_Agent=Go-http-client/1.1
Http_Accept_Encoding=gzip
Http_Method=POST
Http_ContentLength=-1
Http_Path=/function/env
...
Http_Query=workshop=1
...</code></pre>
<p>
在 python 代码中，你应该输入 os.getenv(“Http_Query”)</p>
<ul>
  <li>
现在用一个 header 调用函数：  </li>
</ul>
<pre><code>$ echo &quot;&quot; | curl http://127.0.0.1:8080/function/env --header &quot;X-Output-Mode: json&quot;
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
HOSTNAME=05e8db360c5a
fprocess=env
HOME=/root
Http_X_Call_Id=8e597bcf-614f-4ca5-8f2e-f345d660db5e
Http_X_Forwarded_For=10.255.0.2
Http_X_Start_Time=1519729577415481886
Http_Accept=*/*
Http_Accept_Encoding=gzip
Http_Connection=close
Http_User_Agent=curl/7.55.1
Http_Method=GET
Http_ContentLength=0
Http_Path=/function/env
...
Http_X_Output_Mode=json
...</code></pre>
<p>
在 python 代码中，你应该输入 os.getenv(“Http_X_Outout_Mode”)。</p>
<p>
你可以看到，当 Http_Method 是 POST 方法时， 所有的其他 HTTP 上下文也被提供了出来，比如 Content-Length，<code class="inline">User_Agent</code>， Cookies 和其他 HTTP 请求中应有的参数。</p>
<h2>
利用日志</h2>
<p>
OpenFaaS 的 watchdog 是通过标准 IO 流的 stdin 和 stdout 处理 HTTP 请求和读取 HTTP 响应。这意味着作为一个函数的进程不需要知道任何 web 和 HTTP 的信息。</p>
<p>
一个有趣的情况是当函数以非零的退出且 stderr 不为空。默认情况下，函数的 stdout/stderr 被合并了，且 stderr 不会被打印到日志里。</p>
<p>
让我们使用 Lab3 的函数 hello-openfaas 验证一下。</p>
<p>
修改 handler.py 为：</p>
<pre><code>import sys
import json

def handle(req):

    sys.stderr.write(&quot;This should be an error message.\n&quot;)
    return json.dumps({&quot;Hello&quot;: &quot;OpenFaaS&quot;})</code></pre>
<p>
构建并部署：</p>
<pre><code class="sh">$ faas-cli build -f hello-openfaas.yml \
  &amp;&amp; faas-cli push -f hello-openfaas.yml \
  &amp;&amp; faas-cli deploy -f hello-openfaas.yml</code></pre>
<p>
然后调用函数：</p>
<pre><code class="sh">$ echo | faas-cli invoke hello-openfaas</code></pre>
<p>
你应该可以看到合并之后的输出：</p>
<pre><code>This should be an error message.
{&quot;Hello&quot;: &quot;OpenFaaS&quot;}</code></pre>
<blockquote>
  <p>
说明：如果使用<code class="inline">docker service logs hello-openfaas</code>检查容器的日志，你应该看不到 stderr 输出。  </p>
</blockquote>
<p>
在这个例子中，我们需要函数返回一个可被解析的合法 JSON。不幸的是日志信息使得输出不可用，所以我们需要重定向 stderr 的信息到容器的日志中。OpenFaaS 提供了一个解决方案即：只返回 stdout，因此你可以打印日志的错误信息并且保证函数的返回是清晰的。</p>
<p>
为了达到目的，你应该使用<code class="inline">combine_output</code>参数：</p>
<p>
让我们尝试一下。打开<code class="inline">hello-openfaas.yaml</code>文件，然后添加下面这几行：</p>
<pre><code class="yaml">    environment:
      combine_output: false</code></pre>
<p>
推送部署并调用函数。</p>
<p>
输出应该是：</p>
<pre><code>{&quot;Hello&quot;: &quot;OpenFaaS&quot;}</code></pre>
<p>
检查容易的 stderr 日志。你应该可以看到如下类似的消息：</p>
<pre><code>hello-openfaas.1.2xtrr2ckkkth@linuxkit-025000000001    | 2018/04/03 08:35:24 stderr: This should be an error message.</code></pre>
<h2>
创建工作流程</h2>
<p>
在某些情况下，将一个函数的输出作为另一个函数的输入是很有用的。通过客户端或者 API 网关都可以实现。</p>
<h3>
在客户端的函数链</h3>
<p>
你可以使用 curl，faas-cli 或者你自己的其他代码将一个函数的结果传给另一个函数。这是一个例子：</p>
<p>
优点：</p>
<ul>
  <li>
requires no code - can be done with CLI programs  </li>
  <li>
无需代码——可以使用 CLI 程序完成  </li>
  <li>
fast for development and testing  </li>
  <li>
快速开发测试  </li>
  <li>
easy to model in code  </li>
  <li>
易于在代码中建模  </li>
</ul>
<p>
缺点：</p>
<ul>
  <li>
additional latency - each function goes back to the server  </li>
  <li>
额外的延迟——每个函数都要返回到服务器  </li>
  <li>
chatty (more messages)  </li>
  <li>
繁琐（更多的消息）  </li>
</ul>
<p>
例子：</p>
<ul>
  <li>
    <p>
从函数商店中部署一个 Nodeinfo 函数    </p>
  </li>
  <li>
    <p>
把 NodeInfo 的输出传给 Markdown。    </p>
  </li>
</ul>
<pre><code class="sh">$ echo -n &quot;&quot; | faas-cli invoke nodeinfo | faas-cli invoke func_markdown
&lt;p&gt;Hostname: 64767782518c&lt;/p&gt;

&lt;p&gt;Platform: linux
Arch: x64
CPU count: 4
Uptime: 1121466&lt;/p&gt;</code></pre>
<p>
你现在将会看到 NodeInfo 函数的输出被 HTML 标签装饰了。</p>
<p>
客户端函数链的另一个例子是生成一个图片，然后把它传给另一个加水印的函数。</p>
<h3>
从一个函数中调用另一个函数</h3>
<p>
最简单的函数间调用是通过 OpenFaaS 的 API 网关做一个 HTTP 调用。这个调用是不用知道外部域名或 IP 地址，他可以简单通过 DNS 条目把 API 网关作为一个 gateway。</p>
<p>
在一个函数中访问 API 网关服务时，最好使用环境变量来配置主机名，这是很重要的，原因有两个——名字可能会改变，并且在 Kubernetes 中有时需要后缀</p>
<p>
优点：</p>
<ul>
  <li>
    <p>
函数可以直接使用对方    </p>
  </li>
  <li>
    <p>
因为是在同一网络中互相访问，延迟较低    </p>
  </li>
</ul>
<p>
缺点：</p>
<ul>
  <li>
需要一个 HTTP 请求的库  </li>
</ul>
<p>
例子：</p>
<p>
在 Lab3 中，我们介绍了 requests 包并且使用它去调用 ISS 获取一个宇航员的名字。我们可以使用相同的技术调用部署在 OpenFaaS 中的其他函数。</p>
<ul>
  <li>
打开函数商店然后部署<em>Sentiment Analysis</em>函数。  </li>
</ul>
<p>
Sentiment Analysis 函数将会告诉你任意一个句子的主动性和倾向（积极性评级）。这个函数的结果是一个格式化的 JSON，如下面例子所示：</p>
<pre><code class="sh">$ echo -n &quot;California is great, it&#39;s always sunny there.&quot; | faas-cli invoke sentimentanalysis
{&quot;polarity&quot;: 0.8, &quot;sentence_count&quot;: 1, &quot;subjectivity&quot;: 0.75}</code></pre>
<p>
这个结果显示我们的测试句子非常有主动性（75%）且很积极（80%）。这两个字段的值在-1.00 和 1.00 之间。</p>
<p>
下面的代码被用于在任何一个函数中调用 <em>Sentiment Analysis</em>函数：</p>
<pre><code>    test_sentence = &quot;California is great, it&#39;s always sunny there.&quot;
    r = requests.get(&quot;http://gateway:8080/function/sentimentanalysis&quot;, text= test_sentence)</code></pre>
<p>
或者通过一个环境变量：</p>
<pre><code>    gateway_hostname = os.getenv(&quot;gateway_hostname&quot;, &quot;gateway&quot;) # uses a default of &quot;gateway&quot; for when &quot;gateway_hostname&quot; is not set
    test_sentence = &quot;California is great, it&#39;s always sunny there.&quot;
    r = requests.get(&quot;http://&quot; + gateway_hostname + &quot;:8080/function/sentimentanalysis&quot;, text= test_sentence)</code></pre>
<p>
因为结果总是 JSON 格式的，所示我们可以使用.json()转化响应。</p>
<pre><code>    result = r.json()
    if result[&quot;polarity&quot;] &gt; 0.45:
       return &quot;That was probably positive&quot;
    else:
        return &quot;That was neutral or negative&quot;</code></pre>
<p>
现在创建一个 Python 函数，然后合并在一起：</p>
<pre><code>import os
import requests
import sys

def handle(req):
    &quot;&quot;&quot;handle a request to the function
    Args:
        req (str): request body
    &quot;&quot;&quot;

    gateway_hostname = os.getenv(&quot;gateway_hostname&quot;, &quot;gateway&quot;) # uses a default of &quot;gateway&quot; for when &quot;gateway_hostname&quot; is not set

    test_sentence = req

    r = requests.get(&quot;http://&quot; + gateway_hostname + &quot;:8080/function/sentimentanalysis&quot;, data= test_sentence)

    if r.status_code != 200:
        sys.exit(&quot;Error with sentimentanalysis, expected: %d, got: %d\n&quot; % (200, r.status_code))

    result = r.json()
    if result[&quot;polarity&quot;] &gt; 0.45:
        return &quot;That was probably positive&quot;
    else:
        return &quot;That was neutral or negative&quot;</code></pre>
<ul>
  <li>
记得把 requests 添加到 requirements.txt 文件里  </li>
</ul>
<p>
说明：你不需要修改 SentimentAnalysis 函数的源码，我们已经把它部署了，可以通过 API 网关获取。</p>
<p>
现在进入 Lab 5。</p>

            </article>
        </div>
    </body>
</html>

    