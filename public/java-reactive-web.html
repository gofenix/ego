<html>
    <head>
        <title> 
            java-reactive-web
        </title>

    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.1.0/build/styles/default.min.css"
    />
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.1.0/build/highlight.min.js"></script>

    <script>
      hljs.highlightAll();
    </script>

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      .markdown-body {
        box-sizing: border-box;
        min-width: 200px;
        max-width: 980px;
        margin: 0 auto;
        padding: 45px;
      }

      @media (max-width: 767px) {
        .markdown-body {
          padding: 15px;
        }
      }
    </style>
    </head>

    <body>
        <div>
            <article class="markdown-body"> 
                <hr class="thin" />
<p>
date: “2018-06-23 15:05:32”
title: java-reactive-web</p>
<hr class="thin" />
<p>
Spring web mvc： 传统servlet web</p>
<p>
spring web flux： Reactive web</p>
<ul>
  <li>
编程模式： non-blocking  非阻塞    <ul>
      <li>
nio：同步？异步？      </li>
    </ul>
  </li>
  <li>
并行模型    <ul>
      <li>
sync 同步      </li>
      <li>
async 异步      </li>
    </ul>
  </li>
</ul>
<h1>
Reactive 概念</h1>
<p>
Reactive programming： 响应式编程</p>
<p>
In <a href="https://en.wikipedia.org/wiki/Computing">computing</a>, <strong>reactive programming</strong> is a declarative <a href="https://en.wikipedia.org/wiki/Programming_paradigm">programming paradigm</a> concerned with <a href="https://en.wikipedia.org/wiki/Dataflow_programming">data streams</a> and the propagation of change. With this paradigm it is possible to express static (e.g. arrays) or dynamic (e.g. event emitters) <em>data streams</em> with ease, and also communicate that an inferred dependency within the associated <em>execution model</em> exists, which facilitates the automatic propagation of the changed data flow.</p>
<h2>
实现框架</h2>
<ul>
  <li>
    <p>
RxJava    </p>
    <p>
ReactiveX is a library for composing asynchronous and event-based programs by using observable sequences.
这种就是推的模式    </p>
    <pre><code>int[] a=[1, 2, 3]
for(int i: a){
}</code></pre>
    <pre><code>package com.reactive.demo.reactivedemo;
import java.util.Observable;
/**
 * todo
 *
 * @author zhuzhenfeng
 * @date 2018/6/23
 */
public class ObserverPatternDemo {
    public static void main(String[] args) {
        MyObservable observable = new MyObservable();
        // 1 observable   n个observer
        observable.addObserver((o, value) -&gt; {
            System.out.println(&quot;1 收到数据更新&quot; + value);
        });
        observable.addObserver((o, value) -&gt; {
            System.out.println(&quot;2 收到数据更新&quot; + value);
        });
        observable.setChanged();
        observable.notifyObservers(&quot;hello world&quot;);//  push data 发布数据
    }
    public static class MyObservable extends Observable {
        @Override
        protected synchronized void setChanged() {
            super.setChanged();
        }
    }
}</code></pre>
    <pre><code>/Library/Java/JavaVirtualMachines/jdk1.8.0_152.jdk/Contents/Home/bin/java &quot;-
2 收到数据更新hello world
1 收到数据更新hello world
Process finished with exit code 0</code></pre>
    <p>
当时不阻塞，后续回调。非阻塞基本上采用callback的形式。
对于java来讲，异步代表切换了线程。
当前的实现： 同步+非阻塞
如果是切换了线程，代表是异步 的非阻塞，一般是gui程序的。    </p>
  </li>
  <li>
    <p>
Reactor    </p>
  </li>
</ul>
<h2>
特性</h2>
<ul>
  <li>
异步  </li>
  <li>
非阻塞  </li>
  <li>
事件驱动  </li>
  <li>
可能有背压 backpressure  </li>
  <li>
防止回调地狱  </li>
  <li>
  </li>
</ul>
<h1>
Reactive 使用场景</h1>
<p>
Long Live 模式： netty的io连接（rpc） timeout</p>
<p>
short live模式：不太适合Reactive web，因为这是等待。只是会快速返回，但是并不会给你真正的结果。短频快的连接，不太有用武之地。</p>
<ul>
  <li>
http  </li>
  <li>
http超时时间  </li>
</ul>
<h1>
Reactive 理解误区</h1>
<p>
web：快速响应</p>
<p>
200 Q-&gt;200 T -&gt; 50T</p>
<p>
1-50</p>
<p>
Tomcat connector thread pool(200)-&gt;reactive thread pool(50)</p>
<p>
io连接从Tomcat-&gt;Reactive</p>
<p>
连接</p>
<p>
Reactive thread pool（50）</p>
<p>
不太适合web请求。</p>
<p>
webflux其实并不会提升性能。</p>
<p>
  <img src="http://ww1.sinaimg.cn/large/b831e4c7gy1fsl9ian4ezj20ma0g7tg4.jpg" alt="" />
</p>
<p>
少量的线程，少量的内存来做更好的伸缩性，而并不是为了提升更好的性能。使用Reactive只会是使单位时间内接受请求的数量增加，单位时间内的处理请求的数量下降。</p>

            </article>
        </div>
    </body>
</html>

    