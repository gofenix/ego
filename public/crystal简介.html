<html>
    <head>
        <title> 
            crystal简介
        </title>

    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.1.0/build/styles/default.min.css"
    />
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.1.0/build/highlight.min.js"></script>

    <script>
      hljs.highlightAll();
    </script>

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      .markdown-body {
        box-sizing: border-box;
        min-width: 200px;
        max-width: 980px;
        margin: 0 auto;
        padding: 45px;
      }

      @media (max-width: 767px) {
        .markdown-body {
          padding: 15px;
        }
      }
    </style>
    </head>

    <body>
        <div>
            <article class="markdown-body"> 
                <hr class="thin" />
<p>
date: “2019-08-27T02:14:18.124Z”
title: crystal简介</p>
<hr class="thin" />
<p>
关注 crystal 也有一段时间了，看到多线程的 pr 已经提了，今天简单写一下。</p>
<blockquote>
  <p>
Fast as C, Slick as Ruby  </p>
</blockquote>
<h1>
语法</h1>
<p>
crystal 的语法和 Ruby 比较类似。</p>
<pre><code class="ruby"># A very basic HTTP server
require &quot;http/server&quot;

server = HTTP::Server.new do |context|
  context.response.content_type = &quot;text/plain&quot;
  context.response.print &quot;Hello world, got #{context.request.path}!&quot;
end

puts &quot;Listening on http://127.0.0.1:8080&quot;
server.listen(8080)</code></pre>
<h1>
类型系统</h1>
<p>
crystal 的一大卖点就是静态类型系统，但是写起来又和脚本语言类似。</p>
<pre><code class="ruby">def shout(x)
  # Notice that both Int32 and String respond_to `to_s`
  x.to_s.upcase
end

foo = ENV[&quot;FOO&quot;]? || 10

typeof(foo) # =&gt; (Int32 | String)
typeof(shout(foo)) # =&gt; String</code></pre>
<h1>
空引用检查</h1>
<p>
crystal 可以在编译的时候检查空引用，避免出现空指针异常。</p>
<pre><code class="ruby">if rand(2) &gt; 0
  my_string = &quot;hello world&quot;
end

puts my_string.upcase</code></pre>
<p>
如果运行上述的代码，执行结果如下：</p>
<pre><code class="shell">$ crystal hello_world.cr
Error in hello_world.cr:5: undefined method &#39;upcase&#39; for Nil (compile-time type is (String | Nil))

puts my_string.upcase</code></pre>
<h1>
宏</h1>
<p>
另一个重要的特性是宏。通过宏，可以实现向 ruby 那么强大的元编程。</p>
<pre><code class="ruby">class Object
  def has_instance_var?(name) : Bool
    {{ @type.instance_vars.map &amp;.name.stringify }}.includes? name
  end
end

person = Person.new &quot;John&quot;, 30
person.has_instance_var?(&quot;name&quot;) #=&gt; true
person.has_instance_var?(&quot;birthday&quot;) #=&gt; false</code></pre>
<h1>
并发</h1>
<p>
crystal 的并发是通过绿色线程实现的，即 fibers。和 Go 的并发模式很像，也是基于 channel 的 CSP 模型。</p>
<pre><code class="ruby">channel = Channel(Int32).new
total_lines = 0
files = Dir.glob(&quot;*.txt&quot;)

files.each do |f|
  spawn do
    lines = File.read(f).lines.size
    channel.send lines
  end
end

files.size.times do
  total_lines += channel.receive
end

puts total_lines</code></pre>
<h1>
C 绑定</h1>
<p>
C 语言一般用来实现比较底层的系统，而且 C 的生态丰富，一般现代语言都会提供 C 绑定，来复用 C 的生态。</p>
<pre><code class="ruby"># Fragment of the BigInt implementation that uses GMP
@[Link(&quot;gmp&quot;)]
lib LibGMP
  alias Int = LibC::Int
  alias ULong = LibC::ULong

  struct MPZ
    _mp_alloc : Int32
    _mp_size : Int32
    _mp_d : ULong*
  end

  fun init_set_str = __gmpz_init_set_str(rop : MPZ*, str : UInt8*, base : Int) : Int
  fun cmp = __gmpz_cmp(op1 : MPZ*, op2 : MPZ*) : Int
end

struct BigInt &lt; Int
  def initialize(str : String, base = 10)
    err = LibGMP.init_set_str(out @mpz, str, base)
    raise ArgumentError.new(&quot;invalid BigInt: #{str}&quot;) if err == -1
  end

  def &lt;=&gt;(other : BigInt)
    LibGMP.cmp(mpz, other)
  end
end</code></pre>
<h1>
依赖管理</h1>
<p>
任何一个偏工程性的语言，都会提供一个包管理系统。crystal 的包管理是 shards，其实和 go module 类似。这种项目级别的包管理其实更为实用一些。</p>
<p>
但是 go 的任何一个项目，其实都可以是一个包，crystal 还是会有一些限制的。</p>
<pre><code class="ruby">name: my-project
version: 0.1
license: MIT

crystal: 0.21.0

dependencies:
  mysql:
    github: crystal-lang/crystal-mysql
    version: ~&gt; 0.3.1</code></pre>

            </article>
        </div>
    </body>
</html>

    